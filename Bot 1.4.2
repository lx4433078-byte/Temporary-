"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ”¥ DareDevil Video Bot v1.3 - UPDATED                                   â•‘
â•‘                         High-Performance Edition                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

UPDATES IN THIS VERSION:
âœ… Fixed /uncategorized command (manual + button)
âœ… Fixed /settime button with quick options
âœ… Added checkmark selection (âœ…) for batch operations
âœ… Fixed all animation settings (actually work now)
âœ… Added start animation (ğŸ¤–) and contact animation (ğŸ“)
âœ… Added bot status in /start message
âœ… Added 7 caption design templates
âœ… Fixed /listcategories dual-mode support
âœ… All existing features preserved

FEATURES:
- SQLite database with aiosqlite
- 10,000+ concurrent user support
- Category & batch management
- Subscription system
- Analytics & statistics
- Broadcast system
- Multiple caption templates
- Animation system
- Sub-admin support
"""

import os
import logging
import asyncio
import re
import aiosqlite
from datetime import datetime, timedelta, timezone
from difflib import SequenceMatcher
from collections import defaultdict, Counter
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ContextTypes,
    filters,
    ConversationHandler,
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš™ï¸ CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
BOT_TOKEN = "8350940751:AAFoDS4IZADqFYxewhMhKkkklTLxPZ5Z84E"
ADMIN_ID = 8544636383
SUB_ADMINS = set()  # Sub-admins set
CHANNEL_ID = -1003306079034
LOG_CHANNEL_ID = -1003372715774
BOT_USERNAME = "Daredevil_XVX_bot"
BOT_DISPLAY_NAME = "ğŸ”¥ DareDevil ğŸ‘¿ Video Bot â–¶ï¸"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ DATABASE PATHS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DATA_DIR = ".data"
DB_PATH = os.path.join(DATA_DIR, "bot_database.db")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš™ï¸ BOT SETTINGS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
AUTO_DELETE_SEC = 60
ANIMATION_TIME = 1.5
BACKUP_WAIT_TIME = 3600
MAX_RETRIES = 3
RETRY_DELAY = 2
FUZZY_MATCH_THRESHOLD = 0.6

# Performance settings
MAX_CONCURRENT_WORKERS = 100
CACHE_REFRESH_INTERVAL = 30
BATCH_WRITE_INTERVAL = 30
BROADCAST_RATE_LIMIT = 0.03
USER_REQUEST_TIMEOUT = 30

# Conversation states
WAITING_FOR_BATCH_NAME = 1
WAITING_FOR_CATEGORY_NAME = 2
WAITING_FOR_RENAME_OLD = 3
WAITING_FOR_RENAME_NEW = 4
WAITING_FOR_EMOJI = 5
ADMIN_PANEL_STATE = 100

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”§ LOGGING SETUP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
os.makedirs(DATA_DIR, exist_ok=True)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸŒ GLOBAL VARIABLES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
users_searching = {}
_backup_task = None
active_retries = {}
pending_operations = {}  # For multi-step operations
selected_items = {}  # NEW: Track selected items with checkmarks
broadcast_queue = asyncio.Queue()
user_request_queue = asyncio.Queue()
broadcast_active = False
task_pool = []
db_pool = None
db_semaphore = asyncio.Semaphore(50)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¨ CAPTION DESIGN TEMPLATES (NEW FEATURE)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CAPTION_TEMPLATES = {
    "classic_box": {
        "name": "Classic Box Design",
        "description": "Original box design with borders"
    },
    "minimal": {
        "name": "Minimal Clean",
        "description": "Simple and clean layout"
    },
    "modern_card": {
        "name": "Modern Card",
        "description": "Card-style modern design"
    },
    "elegant": {
        "name": "Elegant Premium",
        "description": "Premium elegant style"
    },
    "compact": {
        "name": "Compact Info",
        "description": "Space-efficient compact view"
    },
    "detailed": {
        "name": "Detailed View",
        "description": "Full information display"
    },
    "gradient": {
        "name": "Gradient Style",
        "description": "Colorful gradient design"
    }
}


def _template_classic_box(batch, titles, date, extracted):
    """Classic box design (original)"""
    formatted = []
    batch_upper = batch.upper()
    box_width = max(len(batch_upper) + 10, 25)
    
    formatted.append("â”Œ" + "â”€" * box_width + "â”")
    formatted.append(f"â”‚     ğŸ“š {batch_upper.center(box_width - 8)}â”‚")
    formatted.append("â””" + "â”€" * box_width + "â”˜")
    
    if titles:
        formatted.append("")
        for i, title in enumerate(titles):
            if i == 0:
                formatted.append(f"ğŸ“– {title}")
            else:
                formatted.append(f"   {title}")
    
    if date:
        formatted.append("")
        formatted.append(f"ğŸ“… Date: {date}")
    
    if extracted:
        formatted.append("")
        formatted.append(f"ğŸ‘¤ Extracted by: {extracted}")
    
    formatted.append("")
    formatted.append("â”€" * box_width)
    
    return '\n'.join(formatted)


def _template_minimal(batch, titles, date, extracted):
    """Minimal clean design"""
    formatted = []
    
    formatted.append(f"ğŸ“š <b>{batch}</b>")
    formatted.append("")
    
    if titles:
        for title in titles:
            formatted.append(title)
    
    formatted.append("")
    info_parts = []
    if date:
        info_parts.append(f"ğŸ“… {date}")
    if extracted:
        info_parts.append(f"ğŸ‘¤ {extracted}")
    
    if info_parts:
        formatted.append(" | ".join(info_parts))
    
    return '\n'.join(formatted)


def _template_modern_card(batch, titles, date, extracted):
    """Modern card style"""
    formatted = []
    
    formatted.append("â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®")
    formatted.append(f"â”‚  ğŸ“š <b>{batch}</b>")
    formatted.append("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
    
    if titles:
        formatted.append("â”‚")
        for title in titles:
            formatted.append(f"â”‚  ğŸ“– {title}")
    
    if date or extracted:
        formatted.append("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
        if date:
            formatted.append(f"â”‚  ğŸ“… {date}")
        if extracted:
            formatted.append(f"â”‚  ğŸ‘¤ {extracted}")
    
    formatted.append("â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯")
    
    return '\n'.join(formatted)


def _template_elegant(batch, titles, date, extracted):
    """Elegant premium style"""
    formatted = []
    
    formatted.append("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    formatted.append(f"     ğŸ“š <b>{batch.upper()}</b>")
    formatted.append("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    formatted.append("")
    
    if titles:
        for i, title in enumerate(titles):
            if i == 0:
                formatted.append(f"â—ˆ <b>{title}</b>")
            else:
                formatted.append(f"  {title}")
        formatted.append("")
    
    if date:
        formatted.append(f"â—† Date: {date}")
    if extracted:
        formatted.append(f"â—† By: {extracted}")
    
    formatted.append("")
    formatted.append("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    
    return '\n'.join(formatted)


def _template_compact(batch, titles, date, extracted):
    """Compact space-efficient"""
    formatted = []
    
    formatted.append(f"ğŸ“š <b>{batch}</b>")
    
    if titles:
        formatted.append(f"ğŸ“– {' â€¢ '.join(titles)}")
    
    info_parts = []
    if date:
        info_parts.append(f"ğŸ“…{date}")
    if extracted:
        info_parts.append(f"ğŸ‘¤{extracted}")
    
    if info_parts:
        formatted.append(" â”‚ ".join(info_parts))
    
    return '\n'.join(formatted)


def _template_detailed(batch, titles, date, extracted):
    """Detailed full information"""
    formatted = []
    
    formatted.append("â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“")
    formatted.append(f"ğŸ“š <b>BATCH INFORMATION</b>")
    formatted.append("â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“")
    formatted.append("")
    formatted.append(f"ğŸ“‚ Batch Name: <b>{batch}</b>")
    formatted.append("")
    
    if titles:
        formatted.append("ğŸ“– <b>Content:</b>")
        for i, title in enumerate(titles, 1):
            formatted.append(f"   {i}. {title}")
        formatted.append("")
    
    if date:
        formatted.append(f"ğŸ“… <b>Date:</b> {date}")
    if extracted:
        formatted.append(f"ğŸ‘¤ <b>Extracted by:</b> {extracted}")
    
    formatted.append("")
    formatted.append("â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“")
    
    return '\n'.join(formatted)


def _template_gradient(batch, titles, date, extracted):
    """Colorful gradient style"""
    formatted = []
    
    formatted.append("â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘")
    formatted.append(f"â–“â–“ ğŸ“š <b>{batch}</b> â–“â–“")
    formatted.append("â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘")
    formatted.append("")
    
    if titles:
        for title in titles:
            formatted.append(f"â–¸ {title}")
        formatted.append("")
    
    info_line = []
    if date:
        info_line.append(f"ğŸ“… {date}")
    if extracted:
        info_line.append(f"ğŸ‘¤ {extracted}")
    
    if info_line:
        formatted.append(" â—† ".join(info_line))
    
    formatted.append("")
    formatted.append("â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘")
    
    return '\n'.join(formatted)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ—„ï¸ SQLITE DATABASE INITIALIZATION (UPDATED)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def init_database():
    """Initialize SQLite database with all tables and optimizations"""
    async with aiosqlite.connect(DB_PATH) as db:
        # Enable WAL mode for better concurrent access
        await db.execute("PRAGMA journal_mode=WAL")
        await db.execute("PRAGMA synchronous=NORMAL")
        await db.execute("PRAGMA cache_size=10000")
        await db.execute("PRAGMA temp_store=MEMORY")
        await db.execute("PRAGMA mmap_size=30000000000")
        
        # Users table
        await db.execute("""
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY,
                username TEXT,
                joined_at TEXT,
                usage_today INTEGER DEFAULT 0,
                usage_date TEXT,
                blocked INTEGER DEFAULT 0,
                daily_limit INTEGER DEFAULT 5,
                extra_granted INTEGER DEFAULT 0,
                bonus_claimed_date TEXT,
                silent_mode TEXT,
                total_downloads INTEGER DEFAULT 0,
                last_active TEXT,
                search_count INTEGER DEFAULT 0,
                favorite_batch TEXT,
                is_sub_admin INTEGER DEFAULT 0
            )
        """)
        
        # Videos table
        await db.execute("""
            CREATE TABLE IF NOT EXISTS videos (
                msg_id INTEGER PRIMARY KEY,
                file_id TEXT NOT NULL,
                caption TEXT,
                batch TEXT,
                file_type TEXT,
                added_at TEXT
            )
        """)
        
        # Categories table
        await db.execute("""
            CREATE TABLE IF NOT EXISTS categories (
                category_name TEXT PRIMARY KEY,
                created_at TEXT,
                created_by INTEGER,
                emoji TEXT DEFAULT 'ğŸ“š'
            )
        """)
        
        # Category batches mapping
        await db.execute("""
            CREATE TABLE IF NOT EXISTS category_batches (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                category_name TEXT,
                batch_name TEXT,
                UNIQUE(category_name, batch_name),
                FOREIGN KEY (category_name) REFERENCES categories(category_name) ON DELETE CASCADE
            )
        """)
        
        # Subscriptions table
        await db.execute("""
            CREATE TABLE IF NOT EXISTS subscriptions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                batch_name TEXT,
                subscribed_at TEXT,
                notification_enabled INTEGER DEFAULT 1,
                UNIQUE(user_id, batch_name)
            )
        """)
        
        # User history table
        await db.execute("""
            CREATE TABLE IF NOT EXISTS user_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                video_id INTEGER,
                action TEXT,
                timestamp TEXT
            )
        """)
        
        # Analytics events table
        await db.execute("""
            CREATE TABLE IF NOT EXISTS analytics (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_type TEXT,
                user_id INTEGER,
                timestamp TEXT,
                details TEXT
            )
        """)
        
        # Batch metadata table
        await db.execute("""
            CREATE TABLE IF NOT EXISTS batch_metadata (
                batch_name TEXT PRIMARY KEY,
                subscribers INTEGER DEFAULT 0,
                total_videos INTEGER DEFAULT 0,
                created_at TEXT
            )
        """)
        
        # Bot settings table
        await db.execute("""
            CREATE TABLE IF NOT EXISTS bot_settings (
                key TEXT PRIMARY KEY,
                value TEXT
            )
        """)
        
        # Emoji settings table
        await db.execute("""
            CREATE TABLE IF NOT EXISTS emoji_settings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                setting_type TEXT,
                setting_key TEXT,
                emoji TEXT,
                UNIQUE(setting_type, setting_key)
            )
        """)
        
        # Database deletions log
        await db.execute("""
            CREATE TABLE IF NOT EXISTS deletion_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                deletion_type TEXT,
                deleted_items TEXT,
                deleted_by INTEGER,
                deleted_at TEXT
            )
        """)
        
        # Create indexes for better performance
        await db.execute("CREATE INDEX IF NOT EXISTS idx_users_blocked ON users(blocked)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_users_usage_date ON users(usage_date)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_videos_batch ON videos(batch)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_videos_added_at ON videos(added_at)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_subscriptions_user ON subscriptions(user_id)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_subscriptions_batch ON subscriptions(batch_name)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_analytics_event ON analytics(event_type)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_analytics_user ON analytics(user_id)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_history_user ON user_history(user_id)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_category_batches ON category_batches(category_name)")
        
        # Initialize default settings (UPDATED)
        await db.execute("""
            INSERT OR IGNORE INTO bot_settings (key, value) VALUES 
            ('protect_content', 'false'),
            ('auto_delete', 'true'),
            ('auto_delete_seconds', '60'),
            ('grant_all_until', ''),
            ('caption_design', 'true'),
            ('caption_template', 'classic_box'),
            ('auto_footer', 'true'),
            ('footer_name', 'Team Bot'),
            ('animations_enabled', 'true'),
            ('animation_loading_duration', '1.5'),
            ('animation_loading_enabled', 'true'),
            ('animation_processing_duration', '1.0'),
            ('animation_processing_enabled', 'true'),
            ('animation_search_duration', '1.2'),
            ('animation_search_enabled', 'true'),
            ('animation_stats_duration', '0.8'),
            ('animation_stats_enabled', 'true'),
            ('animation_start_duration', '1.5'),
            ('animation_start_enabled', 'true'),
            ('animation_contact_duration', '1.0'),
            ('animation_contact_enabled', 'true')
        """)
        
        # Initialize default emojis (UPDATED - Added start & contact)
        await db.execute("""
            INSERT OR IGNORE INTO emoji_settings (setting_type, setting_key, emoji) VALUES
            ('file_type', 'video', 'â–¶ï¸'),
            ('file_type', 'document', 'ğŸ“„'),
            ('file_type', 'pdf', 'ğŸ“•'),
            ('file_type', 'zip', 'ğŸ“¦'),
            ('file_type', 'txt', 'ğŸ“„'),
            ('ui', 'home', 'ğŸ '),
            ('ui', 'search', 'ğŸ”'),
            ('ui', 'stats', 'ğŸ“Š'),
            ('ui', 'subscriptions', 'ğŸ“¬'),
            ('ui', 'category', 'ğŸ“š'),
            ('ui', 'batch', 'ğŸ“‚'),
            ('animation', 'loading', 'ğŸš€'),
            ('animation', 'processing', 'â³'),
            ('animation', 'search', 'ğŸ”'),
            ('animation', 'stats', 'ğŸ“Š'),
            ('animation', 'start', 'ğŸ¤–'),
            ('animation', 'contact', 'ğŸ“')
        """)
        
        await db.commit()
        logging.info("[DATABASE] Initialized successfully with all tables and indexes")


async def get_db():
    """Get database connection with semaphore protection"""
    await db_semaphore.acquire()
    try:
        db = await aiosqlite.connect(DB_PATH)
        db.row_factory = aiosqlite.Row
        return db
    except Exception as e:
        db_semaphore.release()
        raise e


async def release_db(db):
    """Release database connection"""
    try:
        await db.close()
    finally:
        db_semaphore.release()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ› ï¸ HELPER FUNCTIONS (UPDATED)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def now_ist():
    """Get current time in IST"""
    return datetime.now(timezone(timedelta(hours=5, minutes=30)))


def parse_iso(s): 
    """Parse ISO format datetime string"""
    if not s:
        return None
    try:
        return datetime.fromisoformat(s)
    except:
        return None


async def get_emoji(setting_type, setting_key, default='ğŸ“„'):
    """Get emoji from database"""
    db = await get_db()
    try:
        async with db.execute(
            "SELECT emoji FROM emoji_settings WHERE setting_type = ? AND setting_key = ?",
            (setting_type, setting_key)
        ) as cursor:
            row = await cursor.fetchone()
            return row['emoji'] if row else default
    finally:
        await release_db(db)


async def get_file_emoji(caption, file_type=None):
    """Get emoji based on file type"""
    if file_type:
        if file_type == "document":
            return await get_emoji('file_type', 'document', 'ğŸ“„')
        elif file_type == "video":
            return await get_emoji('file_type', 'video', 'â–¶ï¸')
    
    cap = (caption or "").lower()
    if ".pdf" in cap or "pdf" in cap:
        return await get_emoji('file_type', 'pdf', 'ğŸ“•')
    elif ".zip" in cap or "zip" in cap:
        return await get_emoji('file_type', 'zip', 'ğŸ“¦')
    elif ".txt" in cap or "txt" in cap:
        return await get_emoji('file_type', 'txt', 'ğŸ“„')
    return await get_emoji('file_type', 'video', 'â–¶ï¸')


def get_time_until_reset():
    """Calculate time until daily reset"""
    now = now_ist()
    tomorrow = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
    diff = tomorrow - now
    h, rem = divmod(diff.seconds, 3600)
    m, s = divmod(rem, 60)
    return f"{h}h {m}m {s}s"


def calculate_similarity(str1, str2):
    """Calculate similarity ratio between two strings"""
    return SequenceMatcher(None, str1.lower(), str2.lower()).ratio()


def extract_batch_number(batch_name):
    """Extract number from batch name"""
    match = re.search(r'\d+', batch_name)
    return int(match.group()) if match else None


async def find_similar_batches(query, all_batches, threshold=FUZZY_MATCH_THRESHOLD):
    """Find similar batches using fuzzy matching"""
    similar = []
    query_lower = query.lower()
    query_num = extract_batch_number(query)
    
    for batch in all_batches:
        similarity = calculate_similarity(query, batch)
        if similarity >= threshold:
            similar.append((batch, similarity, 'match'))
            continue
        
        if query_num:
            batch_num = extract_batch_number(batch)
            query_base = re.sub(r'\d+', '', query).strip()
            batch_base = re.sub(r'\d+', '', batch).strip()
            
            base_similarity = calculate_similarity(query_base, batch_base)
            if base_similarity >= 0.8:
                similar.append((batch, base_similarity * 0.8, 'series'))
    
    similar.sort(key=lambda x: x[1], reverse=True)
    return similar


def extract_batch_name(caption):
    """Extract batch name from caption"""
    if not caption:
        return "Unknown"
    
    patterns = [
        r"[Bb][Aa][Tt][Cc][Hh]\s*[:-]\s*(.+)",
        r"[Bb][Aa][Tt][Cc][Hh]\s+(.+)",
    ]
    
    for pattern in patterns:
        match = re.search(pattern, caption, re.I)
        if match:
            return match.group(1).strip()
    
    return "Unknown"


def strip_html(text):
    """Remove HTML tags from text for button labels"""
    if not text:
        return ""
    return re.sub(r'<[^>]+>', '', text)


def format_video_caption_template(original_caption, batch_name, settings, template="classic_box"):
    """Format video caption with selected template"""
    if not original_caption:
        return original_caption
    
    # Parse caption components
    lines = original_caption.split('\n')
    title_lines = []
    date_line = None
    extracted_line = None
    batch_detected = batch_name
    
    for line in lines:
        line_stripped = line.strip()
        if not line_stripped:
            continue
        
        if re.search(r'[Bb]atch\s*[:-]?\s*(.+)', line_stripped):
            match = re.search(r'[Bb]atch\s*[:-]?\s*(.+)', line_stripped)
            batch_detected = match.group(1).strip()
            continue
        
        if re.search(r'[Dd]ate\s*[:-]?\s*(.+)', line_stripped):
            match = re.search(r'[Dd]ate\s*[:-]?\s*(.+)', line_stripped)
            date_line = match.group(1).strip()
            continue
        
        if re.search(r'[Ee]xtracted\s+by\s*[:-]?\s*(.+)', line_stripped):
            match = re.search(r'[Ee]xtracted\s+by\s*[:-]?\s*(.+)', line_stripped)
            extracted_line = match.group(1).strip()
            continue
        
        title_lines.append(line_stripped)
    
    # Auto-footer setting
    if not extracted_line and settings.get('auto_footer', True):
        extracted_line = settings.get('footer_name', 'Team Bot')
    
    # Apply template
    if template == "classic_box":
        return _template_classic_box(batch_detected, title_lines, date_line, extracted_line)
    elif template == "minimal":
        return _template_minimal(batch_detected, title_lines, date_line, extracted_line)
    elif template == "modern_card":
        return _template_modern_card(batch_detected, title_lines, date_line, extracted_line)
    elif template == "elegant":
        return _template_elegant(batch_detected, title_lines, date_line, extracted_line)
    elif template == "compact":
        return _template_compact(batch_detected, title_lines, date_line, extracted_line)
    elif template == "detailed":
        return _template_detailed(batch_detected, title_lines, date_line, extracted_line)
    elif template == "gradient":
        return _template_gradient(batch_detected, title_lines, date_line, extracted_line)
    else:
        return _template_classic_box(batch_detected, title_lines, date_line, extracted_line)


def format_video_caption(original_caption, batch_name, settings):
    """Smart caption formatter with template support"""
    if not original_caption:
        return original_caption
    
    # Get selected template (default: classic_box)
    template = settings.get('caption_template', 'classic_box')
    
    # Use template formatter
    return format_video_caption_template(original_caption, batch_name, settings, template)


async def get_design_settings():
    """Get caption design settings from database"""
    settings = await get_bot_settings()
    return {
        'caption_design': settings.get('caption_design', True),
        'caption_template': settings.get('caption_template', 'classic_box'),
        'auto_footer': settings.get('auto_footer', True),
        'footer_name': settings.get('footer_name', 'Team Bot')
    }


def extract_video_id_from_message(msg):
    """Extract clean video ID from message"""
    return msg.message_id


def format_message_header(title, emoji="ğŸ“Š"):
    """Format consistent message headers"""
    return f"{emoji} <b>{title}</b>\n{'â”€' * 30}\n"


def format_message_footer():
    """Format consistent message footers"""
    return f"\n{'â”€' * 30}"


def format_success_message(message):
    """Format success messages"""
    return f"âœ… <b>SUCCESS</b>\n{'â”€' * 30}\n{message}\n{'â”€' * 30}"


def format_error_message(message):
    """Format error messages"""
    return f"âŒ <b>ERROR</b>\n{'â”€' * 30}\n{message}\n{'â”€' * 30}"


def format_info_message(title, message):
    """Format info messages"""
    return f"â„¹ï¸ <b>{title}</b>\n{'â”€' * 30}\n{message}\n{'â”€' * 30}"


def is_admin(user_id):
    """Check if user is admin or sub-admin"""
    return user_id == ADMIN_ID or user_id in SUB_ADMINS


def is_owner(user_id):
    """Check if user is the owner"""
    return user_id == ADMIN_ID   

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš™ï¸ BOT SETTINGS MANAGEMENT (UPDATED)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def get_animation_settings():
    """Get animation settings from database (FIXED)"""
    db = await get_db()
    try:
        settings = {}
        
        # Get global enabled setting
        async with db.execute(
            "SELECT value FROM bot_settings WHERE key = 'animations_enabled'"
        ) as cursor:
            row = await cursor.fetchone()
            settings['global_enabled'] = row['value'] == 'true' if row else True
        
        # Get all animation emojis
        async with db.execute(
            "SELECT setting_key, emoji FROM emoji_settings WHERE setting_type = 'animation'"
        ) as cursor:
            async for row in cursor:
                anim_type = row['setting_key']
                settings[anim_type] = {'emoji': row['emoji']}
        
        # Get duration and enabled for each animation type (UPDATED - Added start & contact)
        for anim_type in ['loading', 'processing', 'search', 'stats', 'start', 'contact']:
            # Duration
            async with db.execute(
                "SELECT value FROM bot_settings WHERE key = ?",
                (f'animation_{anim_type}_duration',)
            ) as cursor:
                row = await cursor.fetchone()
                duration = float(row['value']) if row else 1.5
            
            # Enabled status
            async with db.execute(
                "SELECT value FROM bot_settings WHERE key = ?",
                (f'animation_{anim_type}_enabled',)
            ) as cursor:
                row = await cursor.fetchone()
                enabled = row['value'] == 'true' if row else True
            
            # Get emoji if not already set
            if anim_type not in settings:
                async with db.execute(
                    "SELECT emoji FROM emoji_settings WHERE setting_type = 'animation' AND setting_key = ?",
                    (anim_type,)
                ) as cursor:
                    row = await cursor.fetchone()
                    emoji = row['emoji'] if row else 'ğŸš€'
                    settings[anim_type] = {'emoji': emoji}
            
            # Add duration and enabled
            settings[anim_type]['duration'] = duration
            settings[anim_type]['enabled'] = enabled
        
        return settings
    finally:
        await release_db(db)


async def show_animation(context, chat_id, anim_type='loading'):
    """Show animation if enabled (FIXED - Actually works now)"""
    settings = await get_animation_settings()
    
    # Check global enabled
    if not settings.get('global_enabled', True):
        return None
    
    # Get animation config
    anim = settings.get(anim_type)
    if not anim or not anim.get('enabled', True):
        return None
    
    emoji = anim.get('emoji', 'ğŸš€')
    duration = anim.get('duration', 1.5)
    
    try:
        # Send animation message
        msg = await context.bot.send_message(
            chat_id=chat_id,
            text=emoji,
            parse_mode=None  # No HTML parsing for emoji
        )
        
        # Wait for duration
        await asyncio.sleep(duration)
        
        # Delete animation message
        try:
            await context.bot.delete_message(chat_id, msg.message_id)
        except:
            pass  # Ignore if already deleted
        
        return True
    except Exception as e:
        logging.error(f"[ANIMATION] Error showing {anim_type}: {e}")
        return None


async def update_animation_setting(anim_type, emoji=None, duration=None, enabled=None):
    """Update animation settings"""
    db = await get_db()
    try:
        if emoji:
            await db.execute(
                "INSERT OR REPLACE INTO emoji_settings (setting_type, setting_key, emoji) VALUES (?, ?, ?)",
                ('animation', anim_type, emoji)
            )
        
        if duration is not None:
            await db.execute(
                "INSERT OR REPLACE INTO bot_settings (key, value) VALUES (?, ?)",
                (f'animation_{anim_type}_duration', str(duration))
            )
        
        if enabled is not None:
            await db.execute(
                "INSERT OR REPLACE INTO bot_settings (key, value) VALUES (?, ?)",
                (f'animation_{anim_type}_enabled', 'true' if enabled else 'false')
            )
        
        await db.commit()
        return True
    finally:
        await release_db(db)


async def toggle_global_animations(enabled):
    """Toggle all animations on/off"""
    await update_bot_setting('animations_enabled', 'true' if enabled else 'false')


async def get_bot_settings():
    """Get all bot settings from database"""
    db = await get_db()
    try:
        settings = {}
        async with db.execute("SELECT key, value FROM bot_settings") as cursor:
            async for row in cursor:
                key = row['key']
                value = row['value']
                # Convert string booleans to actual booleans
                if value in ('true', 'false'):
                    settings[key] = value == 'true'
                elif value.isdigit():
                    settings[key] = int(value)
                else:
                    settings[key] = value
        return settings
    finally:
        await release_db(db)


async def update_bot_setting(key, value):
    """Update a bot setting"""
    db = await get_db()
    try:
        # Convert boolean to string
        if isinstance(value, bool):
            value = 'true' if value else 'false'
        elif isinstance(value, int):
            value = str(value)
        
        await db.execute(
            "INSERT OR REPLACE INTO bot_settings (key, value) VALUES (?, ?)",
            (key, value)
        )
        await db.commit()
        logging.info(f"[SETTINGS] Updated {key} = {value}")
        return True
    finally:
        await release_db(db)


async def get_setting(key, default=None):
    """Get a specific setting"""
    settings = await get_bot_settings()
    return settings.get(key, default)    

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ†• NEW ENHANCED FEATURES - Database Tables
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def init_enhanced_features_tables():
    """Initialize tables for new enhanced features"""
    async with aiosqlite.connect(DB_PATH) as db:
        # Scheduled broadcasts table
        await db.execute("""
            CREATE TABLE IF NOT EXISTS scheduled_broadcasts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                message_text TEXT,
                message_id INTEGER,
                from_chat_id INTEGER,
                scheduled_time TEXT,
                created_by INTEGER,
                created_at TEXT,
                status TEXT DEFAULT 'pending',
                sent_count INTEGER DEFAULT 0,
                failed_count INTEGER DEFAULT 0,
                include_silent INTEGER DEFAULT 0,
                executed_at TEXT
            )
        """)
        
        # Bulk user operations log
        await db.execute("""
            CREATE TABLE IF NOT EXISTS bulk_operations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                operation_type TEXT,
                target_users TEXT,
                operation_data TEXT,
                performed_by INTEGER,
                performed_at TEXT,
                success_count INTEGER DEFAULT 0,
                failed_count INTEGER DEFAULT 0
            )
        """)
        
        # User activity heatmap data
        await db.execute("""
            CREATE TABLE IF NOT EXISTS user_activity (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                activity_date TEXT,
                hour INTEGER,
                activity_count INTEGER DEFAULT 1,
                UNIQUE(user_id, activity_date, hour)
            )
        """)
        
        # Batch video statistics
        await db.execute("""
            CREATE TABLE IF NOT EXISTS batch_statistics (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                batch_name TEXT,
                stat_date TEXT,
                downloads_count INTEGER DEFAULT 0,
                searches_count INTEGER DEFAULT 0,
                unique_users INTEGER DEFAULT 0,
                UNIQUE(batch_name, stat_date)
            )
        """)
        
        # Category export/import history
        await db.execute("""
            CREATE TABLE IF NOT EXISTS category_exports (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                export_name TEXT,
                export_data TEXT,
                exported_by INTEGER,
                exported_at TEXT,
                categories_count INTEGER,
                batches_count INTEGER
            )
        """)
        
        # Create indexes
        await db.execute("CREATE INDEX IF NOT EXISTS idx_scheduled_status ON scheduled_broadcasts(status)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_scheduled_time ON scheduled_broadcasts(scheduled_time)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_activity_user ON user_activity(user_id)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_activity_date ON user_activity(activity_date)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_batch_stats ON batch_statistics(batch_name)")
        
        await db.commit()
        logging.info("[DATABASE] Enhanced features tables initialized")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š ANALYTICS TRACKING (UPDATED - Track activity for heatmap)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def track_event(event_type, user_id, details=None):
    """Track analytics events"""
    db = await get_db()
    try:
        import json
        details_str = json.dumps(details) if details else '{}'
        await db.execute(
            "INSERT INTO analytics (event_type, user_id, timestamp, details) VALUES (?, ?, ?, ?)",
            (event_type, user_id, now_ist().isoformat(), details_str)
        )
        await db.commit()
        
        # Also track for activity heatmap
        await track_user_activity(user_id)
        
    except Exception as e:
        logging.error(f"[ANALYTICS] Error tracking event: {e}")
    finally:
        await release_db(db)


async def track_user_activity(user_id):
    """Track user activity for heatmap (NEW)"""
    db = await get_db()
    try:
        now = now_ist()
        activity_date = now.date().isoformat()
        hour = now.hour
        
        await db.execute("""
            INSERT INTO user_activity (user_id, activity_date, hour, activity_count)
            VALUES (?, ?, ?, 1)
            ON CONFLICT(user_id, activity_date, hour) 
            DO UPDATE SET activity_count = activity_count + 1
        """, (user_id, activity_date, hour))
        
        await db.commit()
    except Exception as e:
        logging.error(f"[ACTIVITY] Error tracking activity: {e}")
    finally:
        await release_db(db)


async def track_batch_download(batch_name, user_id):
    """Track batch download statistics (NEW)"""
    db = await get_db()
    try:
        stat_date = now_ist().date().isoformat()
        
        await db.execute("""
            INSERT INTO batch_statistics (batch_name, stat_date, downloads_count, unique_users)
            VALUES (?, ?, 1, 1)
            ON CONFLICT(batch_name, stat_date)
            DO UPDATE SET 
                downloads_count = downloads_count + 1,
                unique_users = (
                    SELECT COUNT(DISTINCT user_id) 
                    FROM user_history 
                    WHERE video_id IN (SELECT msg_id FROM videos WHERE batch = ?)
                    AND DATE(timestamp) = ?
                )
        """, (batch_name, stat_date, batch_name, stat_date))
        
        await db.commit()
    except Exception as e:
        logging.error(f"[BATCH_STATS] Error tracking: {e}")
    finally:
        await release_db(db)    

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ‘¥ BULK USER MANAGEMENT (NEW FEATURE)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def bulk_block_users(user_ids, admin_id):
    """Block multiple users at once (NEW)"""
    db = await get_db()
    try:
        success = 0
        failed = 0
        
        for uid in user_ids:
            try:
                await db.execute("UPDATE users SET blocked = 1 WHERE user_id = ?", (uid,))
                success += 1
            except:
                failed += 1
        
        await db.commit()
        
        # Log bulk operation
        import json
        await db.execute("""
            INSERT INTO bulk_operations (operation_type, target_users, operation_data, performed_by, performed_at, success_count, failed_count)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, ('bulk_block', json.dumps(user_ids), '{}', admin_id, now_ist().isoformat(), success, failed))
        
        await db.commit()
        
        return success, failed
    finally:
        await release_db(db)


async def bulk_unblock_users(user_ids, admin_id):
    """Unblock multiple users at once (NEW)"""
    db = await get_db()
    try:
        success = 0
        failed = 0
        
        for uid in user_ids:
            try:
                await db.execute("UPDATE users SET blocked = 0 WHERE user_id = ?", (uid,))
                success += 1
            except:
                failed += 1
        
        await db.commit()
        
        # Log bulk operation
        import json
        await db.execute("""
            INSERT INTO bulk_operations (operation_type, target_users, operation_data, performed_by, performed_at, success_count, failed_count)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, ('bulk_unblock', json.dumps(user_ids), '{}', admin_id, now_ist().isoformat(), success, failed))
        
        await db.commit()
        
        return success, failed
    finally:
        await release_db(db)


async def bulk_grant_downloads(user_ids, amount, admin_id):
    """Grant downloads to multiple users (NEW)"""
    db = await get_db()
    try:
        success = 0
        failed = 0
        
        for uid in user_ids:
            try:
                await db.execute(
                    "UPDATE users SET extra_granted = extra_granted + ? WHERE user_id = ?",
                    (amount, uid)
                )
                success += 1
            except:
                failed += 1
        
        await db.commit()
        
        # Log bulk operation
        import json
        await db.execute("""
            INSERT INTO bulk_operations (operation_type, target_users, operation_data, performed_by, performed_at, success_count, failed_count)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, ('bulk_grant', json.dumps(user_ids), json.dumps({'amount': amount}), admin_id, now_ist().isoformat(), success, failed))
        
        await db.commit()
        
        return success, failed
    finally:
        await release_db(db)


async def bulk_reset_users(user_ids, admin_id):
    """Reset usage for multiple users (NEW)"""
    db = await get_db()
    try:
        success = 0
        failed = 0
        
        for uid in user_ids:
            try:
                await db.execute("UPDATE users SET usage_today = 0 WHERE user_id = ?", (uid,))
                success += 1
            except:
                failed += 1
        
        await db.commit()
        
        # Log bulk operation
        import json
        await db.execute("""
            INSERT INTO bulk_operations (operation_type, target_users, operation_data, performed_by, performed_at, success_count, failed_count)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, ('bulk_reset', json.dumps(user_ids), '{}', admin_id, now_ist().isoformat(), success, failed))
        
        await db.commit()
        
        return success, failed
    finally:
        await release_db(db)


async def get_users_by_criteria(criteria):
    """Get users by various criteria (NEW)
    
    Criteria options:
    - 'all': All users
    - 'active': Users who used bot today
    - 'inactive': Users who haven't used bot in 7 days
    - 'blocked': Blocked users
    - 'heavy_users': Users with 50+ downloads
    - 'new_users': Users joined in last 7 days
    """
    db = await get_db()
    try:
        today = now_ist().date().isoformat()
        week_ago = (now_ist() - timedelta(days=7)).isoformat()
        
        if criteria == 'all':
            query = "SELECT user_id FROM users"
            params = ()
        elif criteria == 'active':
            query = "SELECT user_id FROM users WHERE usage_today > 0"
            params = ()
        elif criteria == 'inactive':
            query = "SELECT user_id FROM users WHERE last_active < ?"
            params = (week_ago,)
        elif criteria == 'blocked':
            query = "SELECT user_id FROM users WHERE blocked = 1"
            params = ()
        elif criteria == 'heavy_users':
            query = "SELECT user_id FROM users WHERE total_downloads >= 50"
            params = ()
        elif criteria == 'new_users':
            query = "SELECT user_id FROM users WHERE joined_at >= ?"
            params = (week_ago,)
        else:
            return []
        
        async with db.execute(query, params) as cursor:
            users = []
            async for row in cursor:
                users.append(row['user_id'])
            return users
    finally:
        await release_db(db)  

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“¤ EXPORT/IMPORT CATEGORY STRUCTURE (NEW FEATURE)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def export_category_structure(admin_id):
    """Export all categories and their batches to JSON (NEW)"""
    db = await get_db()
    try:
        import json
        
        export_data = {
            'version': '1.3',
            'exported_at': now_ist().isoformat(),
            'exported_by': admin_id,
            'categories': []
        }
        
        # Get all categories
        async with db.execute(
            "SELECT category_name, emoji, created_at, created_by FROM categories ORDER BY category_name"
        ) as cursor:
            categories = await cursor.fetchall()
        
        total_batches = 0
        
        for cat in categories:
            cat_name = cat['category_name']
            
            # Get batches for this category
            async with db.execute(
                "SELECT batch_name FROM category_batches WHERE category_name = ?",
                (cat_name,)
            ) as cursor:
                batches = []
                async for row in cursor:
                    batches.append(row['batch_name'])
            
            total_batches += len(batches)
            
            export_data['categories'].append({
                'name': cat_name,
                'emoji': cat['emoji'],
                'created_at': cat['created_at'],
                'created_by': cat['created_by'],
                'batches': batches
            })
        
        # Save to database
        export_json = json.dumps(export_data, indent=2)
        export_name = f"category_export_{now_ist().strftime('%Y%m%d_%H%M%S')}"
        
        await db.execute("""
            INSERT INTO category_exports (export_name, export_data, exported_by, exported_at, categories_count, batches_count)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (export_name, export_json, admin_id, now_ist().isoformat(), len(categories), total_batches))
        
        await db.commit()
        
        return export_json, export_name, len(categories), total_batches
        
    finally:
        await release_db(db)


async def import_category_structure(import_data, admin_id, mode='merge'):
    """Import category structure from JSON (NEW)
    
    Modes:
    - 'merge': Add new categories, keep existing
    - 'replace': Delete all, then import
    - 'skip_existing': Only import non-existing categories
    """
    db = await get_db()
    try:
        import json
        
        data = json.loads(import_data)
        
        imported_categories = 0
        imported_batches = 0
        skipped = 0
        errors = 0
        
        # Handle replace mode
        if mode == 'replace':
            await db.execute("DELETE FROM category_batches")
            await db.execute("DELETE FROM categories")
            await db.commit()
        
        # Import categories
        for cat_data in data.get('categories', []):
            cat_name = cat_data['name']
            
            # Check if exists
            async with db.execute(
                "SELECT category_name FROM categories WHERE category_name = ?",
                (cat_name,)
            ) as cursor:
                exists = await cursor.fetchone()
            
            if exists and mode == 'skip_existing':
                skipped += 1
                continue
            
            try:
                # Insert or update category
                await db.execute("""
                    INSERT OR REPLACE INTO categories (category_name, emoji, created_at, created_by)
                    VALUES (?, ?, ?, ?)
                """, (cat_name, cat_data.get('emoji', 'ğŸ“š'), now_ist().isoformat(), admin_id))
                
                imported_categories += 1
                
                # Import batches
                for batch_name in cat_data.get('batches', []):
                    try:
                        await db.execute("""
                            INSERT OR IGNORE INTO category_batches (category_name, batch_name)
                            VALUES (?, ?)
                        """, (cat_name, batch_name))
                        imported_batches += 1
                    except:
                        errors += 1
                
            except Exception as e:
                logging.error(f"[IMPORT] Error importing category {cat_name}: {e}")
                errors += 1
        
        await db.commit()
        
        return {
            'imported_categories': imported_categories,
            'imported_batches': imported_batches,
            'skipped': skipped,
            'errors': errors
        }
        
    finally:
        await release_db(db)


async def list_category_exports():
    """List all saved exports (NEW)"""
    db = await get_db()
    try:
        async with db.execute(
            "SELECT export_name, exported_at, categories_count, batches_count FROM category_exports ORDER BY exported_at DESC LIMIT 10"
        ) as cursor:
            exports = []
            async for row in cursor:
                exports.append(dict(row))
            return exports
    finally:
        await release_db(db)


async def get_export_data(export_name):
    """Get export data by name (NEW)"""
    db = await get_db()
    try:
        async with db.execute(
            "SELECT export_data FROM category_exports WHERE export_name = ?",
            (export_name,)
        ) as cursor:
            row = await cursor.fetchone()
            return row['export_data'] if row else None
    finally:
        await release_db(db)    

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š BATCH VIDEO STATISTICS (NEW FEATURE)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def get_batch_detailed_statistics(batch_name, days=7):
    """Get detailed statistics for a batch (NEW)"""
    db = await get_db()
    try:
        stats = {
            'batch_name': batch_name,
            'total_videos': 0,
            'total_downloads': 0,
            'unique_users': 0,
            'subscribers': 0,
            'daily_stats': [],
            'top_videos': [],
            'popular_times': []
        }
        
        # Total videos
        async with db.execute(
            "SELECT COUNT(*) as count FROM videos WHERE batch = ?",
            (batch_name,)
        ) as cursor:
            row = await cursor.fetchone()
            stats['total_videos'] = row['count']
        
        # Subscribers
        async with db.execute(
            "SELECT COUNT(*) as count FROM subscriptions WHERE batch_name = ?",
            (batch_name,)
        ) as cursor:
            row = await cursor.fetchone()
            stats['subscribers'] = row['count']
        
        # Daily stats for last N days
        start_date = (now_ist() - timedelta(days=days)).date().isoformat()
        async with db.execute(
            "SELECT stat_date, downloads_count, unique_users FROM batch_statistics WHERE batch_name = ? AND stat_date >= ? ORDER BY stat_date DESC",
            (batch_name, start_date)
        ) as cursor:
            async for row in cursor:
                stats['daily_stats'].append({
                    'date': row['stat_date'],
                    'downloads': row['downloads_count'],
                    'users': row['unique_users']
                })
        
        # Total downloads (from history)
        async with db.execute("""
            SELECT COUNT(*) as count, COUNT(DISTINCT user_id) as unique_users
            FROM user_history 
            WHERE video_id IN (SELECT msg_id FROM videos WHERE batch = ?)
        """, (batch_name,)) as cursor:
            row = await cursor.fetchone()
            stats['total_downloads'] = row['count']
            stats['unique_users'] = row['unique_users']
        
        # Top 10 most downloaded videos
        async with db.execute("""
            SELECT v.msg_id, v.caption, COUNT(h.id) as download_count
            FROM videos v
            LEFT JOIN user_history h ON v.msg_id = h.video_id
            WHERE v.batch = ?
            GROUP BY v.msg_id
            ORDER BY download_count DESC
            LIMIT 10
        """, (batch_name,)) as cursor:
            async for row in cursor:
                stats['top_videos'].append({
                    'video_id': row['msg_id'],
                    'caption': row['caption'][:50] if row['caption'] else 'Untitled',
                    'downloads': row['download_count']
                })
        
        # Popular download times (hour of day)
        async with db.execute("""
            SELECT CAST(strftime('%H', timestamp) AS INTEGER) as hour, COUNT(*) as count
            FROM user_history
            WHERE video_id IN (SELECT msg_id FROM videos WHERE batch = ?)
            GROUP BY hour
            ORDER BY count DESC
            LIMIT 5
        """, (batch_name,)) as cursor:
            async for row in cursor:
                stats['popular_times'].append({
                    'hour': row['hour'],
                    'count': row['count']
                })
        
        return stats
        
    finally:
        await release_db(db)


async def get_all_batches_summary():
    """Get summary statistics for all batches (NEW)"""
    db = await get_db()
    try:
        summaries = []
        
        # Get all unique batches
        async with db.execute(
            "SELECT DISTINCT batch FROM videos ORDER BY batch"
        ) as cursor:
            batches = []
            async for row in cursor:
                batches.append(row['batch'])
        
        # Get stats for each batch
        for batch in batches:
            async with db.execute(
                "SELECT COUNT(*) as videos FROM videos WHERE batch = ?",
                (batch,)
            ) as cursor:
                video_count = (await cursor.fetchone())['videos']
            
            async with db.execute(
                "SELECT COUNT(*) as subs FROM subscriptions WHERE batch_name = ?",
                (batch,)
            ) as cursor:
                sub_count = (await cursor.fetchone())['subs']
            
            async with db.execute("""
                SELECT COUNT(*) as downloads
                FROM user_history
                WHERE video_id IN (SELECT msg_id FROM videos WHERE batch = ?)
            """, (batch,)) as cursor:
                download_count = (await cursor.fetchone())['downloads']
            
            summaries.append({
                'batch': batch,
                'videos': video_count,
                'subscribers': sub_count,
                'downloads': download_count
            })
        
        # Sort by downloads
        summaries.sort(key=lambda x: x['downloads'], reverse=True)
        
        return summaries
        
    finally:
        await release_db(db)


async def generate_batch_stats_report(batch_name):
    """Generate formatted text report for batch (NEW)"""
    stats = await get_batch_detailed_statistics(batch_name, days=30)
    
    report = f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          ğŸ“Š BATCH STATISTICS REPORT                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‚ Batch: {batch_name}

ğŸ“ˆ OVERVIEW
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ¥ Total Videos:        {stats['total_videos']}
ğŸ“¥ Total Downloads:     {stats['total_downloads']}
ğŸ‘¥ Unique Users:        {stats['unique_users']}
ğŸ“¬ Subscribers:         {stats['subscribers']}

ğŸ“… DAILY ACTIVITY (Last 30 Days)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"""
    
    for day_stat in stats['daily_stats'][:10]:
        report += f"  {day_stat['date']}: {day_stat['downloads']} downloads by {day_stat['users']} users\n"
    
    if stats['top_videos']:
        report += f"""
ğŸ”¥ TOP 10 MOST DOWNLOADED VIDEOS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"""
        for i, video in enumerate(stats['top_videos'], 1):
            report += f"  {i}. {video['caption']} ({video['downloads']} downloads)\n"
    
    if stats['popular_times']:
        report += f"""
â° POPULAR DOWNLOAD TIMES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"""
        for time_stat in stats['popular_times']:
            hour_str = f"{time_stat['hour']:02d}:00"
            report += f"  {hour_str} - {time_stat['count']} downloads\n"
    
    report += """
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
    
    return report 

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”¥ USER ACTIVITY HEATMAP (NEW FEATURE)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def get_user_activity_heatmap(days=7):
    """Generate activity heatmap data (NEW)"""
    db = await get_db()
    try:
        heatmap = {
            'days': [],
            'hours': list(range(24)),
            'data': {}
        }
        
        # Get last N days
        for i in range(days):
            date = (now_ist() - timedelta(days=i)).date().isoformat()
            heatmap['days'].append(date)
            heatmap['data'][date] = [0] * 24
        
        # Get activity data
        start_date = (now_ist() - timedelta(days=days)).date().isoformat()
        async with db.execute(
            "SELECT activity_date, hour, SUM(activity_count) as total FROM user_activity WHERE activity_date >= ? GROUP BY activity_date, hour",
            (start_date,)
        ) as cursor:
            async for row in cursor:
                date = row['activity_date']
                hour = row['hour']
                total = row['total']
                
                if date in heatmap['data']:
                    heatmap['data'][date][hour] = total
        
        return heatmap
        
    finally:
        await release_db(db)


async def get_user_personal_heatmap(user_id, days=30):
    """Get personal activity heatmap for a user (NEW)"""
    db = await get_db()
    try:
        heatmap = {
            'user_id': user_id,
            'days': [],
            'hours': list(range(24)),
            'data': {}
        }
        
        # Get last N days
        for i in range(days):
            date = (now_ist() - timedelta(days=i)).date().isoformat()
            heatmap['days'].append(date)
            heatmap['data'][date] = [0] * 24
        
        # Get activity data for this user
        start_date = (now_ist() - timedelta(days=days)).date().isoformat()
        async with db.execute(
            "SELECT activity_date, hour, activity_count FROM user_activity WHERE user_id = ? AND activity_date >= ?",
            (user_id, start_date)
        ) as cursor:
            async for row in cursor:
                date = row['activity_date']
                hour = row['hour']
                count = row['activity_count']
                
                if date in heatmap['data']:
                    heatmap['data'][date][hour] = count
        
        return heatmap
        
    finally:
        await release_db(db)


async def generate_heatmap_visual(heatmap_data):
    """Generate ASCII visual representation of heatmap (NEW)"""
    visual = []
    
    # Header
    visual.append("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    visual.append("â•‘              ğŸ”¥ USER ACTIVITY HEATMAP                      â•‘")
    visual.append("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    visual.append("")
    
    # Time labels (0-23)
    time_labels = "     " + "".join([f"{h:2d}" for h in range(0, 24, 3)])
    visual.append(time_labels)
    visual.append("     " + "â”€" * 48)
    
    # Data rows
    intensity_chars = [' ', 'â–‘', 'â–’', 'â–“', 'â–ˆ']
    
    for date in heatmap_data['days']:
        row_data = heatmap_data['data'].get(date, [0] * 24)
        
        # Calculate max for normalization
        max_val = max(row_data) if max(row_data) > 0 else 1
        
        # Create visual row
        row = f"{date[-5:]} â”‚"
        for hour in range(24):
            val = row_data[hour]
            # Normalize to 0-4 range
            intensity = min(4, int((val / max_val) * 4)) if max_val > 0 else 0
            row += intensity_chars[intensity] * 2
        
        visual.append(row)
    
    visual.append("")
    visual.append("Legend: â–ˆ High  â–“ Med-High  â–’ Medium  â–‘ Low  Â· None")
    visual.append("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    
    return "\n".join(visual)


async def get_peak_activity_hours():
    """Get peak activity hours across all users (NEW)"""
    db = await get_db()
    try:
        peak_hours = []
        
        async with db.execute("""
            SELECT hour, SUM(activity_count) as total
            FROM user_activity
            WHERE activity_date >= DATE('now', '-7 days')
            GROUP BY hour
            ORDER BY total DESC
            LIMIT 5
        """) as cursor:
            async for row in cursor:
                peak_hours.append({
                    'hour': row['hour'],
                    'activity': row['total'],
                    'time': f"{row['hour']:02d}:00 - {(row['hour']+1)%24:02d}:00"
                })
        
        return peak_hours
        
    finally:
        await release_db(db)


async def get_activity_trends(days=30):
    """Get activity trends over time (NEW)"""
    db = await get_db()
    try:
        trends = []
        
        start_date = (now_ist() - timedelta(days=days)).date().isoformat()
        
        async with db.execute("""
            SELECT activity_date, SUM(activity_count) as total, COUNT(DISTINCT user_id) as unique_users
            FROM user_activity
            WHERE activity_date >= ?
            GROUP BY activity_date
            ORDER BY activity_date DESC
        """, (start_date,)) as cursor:
            async for row in cursor:
                trends.append({
                    'date': row['activity_date'],
                    'total_activity': row['total'],
                    'unique_users': row['unique_users']
                })
        
        return trends
        
    finally:
        await release_db(db)   

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# â° SCHEDULED BROADCASTS (NEW FEATURE)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def schedule_broadcast(message_text, scheduled_time, admin_id, include_silent=False, message_id=None, from_chat_id=None):
    """Schedule a broadcast for future delivery (NEW)"""
    db = await get_db()
    try:
        await db.execute("""
            INSERT INTO scheduled_broadcasts 
            (message_text, message_id, from_chat_id, scheduled_time, created_by, created_at, include_silent)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (message_text, message_id, from_chat_id, scheduled_time, admin_id, now_ist().isoformat(), 1 if include_silent else 0))
        
        await db.commit()
        
        # Get the ID of inserted broadcast
        async with db.execute(
            "SELECT id FROM scheduled_broadcasts WHERE created_by = ? ORDER BY id DESC LIMIT 1",
            (admin_id,)
        ) as cursor:
            row = await cursor.fetchone()
            return row['id'] if row else None
        
    finally:
        await release_db(db)


async def get_pending_broadcasts():
    """Get broadcasts that are due for sending (NEW)"""
    db = await get_db()
    try:
        current_time = now_ist().isoformat()
        
        async with db.execute(
            "SELECT * FROM scheduled_broadcasts WHERE status = 'pending' AND scheduled_time <= ? ORDER BY scheduled_time",
            (current_time,)
        ) as cursor:
            broadcasts = []
            async for row in cursor:
                broadcasts.append(dict(row))
            return broadcasts
        
    finally:
        await release_db(db)


async def mark_broadcast_sent(broadcast_id, success_count, failed_count):
    """Mark broadcast as sent (NEW)"""
    db = await get_db()
    try:
        await db.execute("""
            UPDATE scheduled_broadcasts 
            SET status = 'sent', sent_count = ?, failed_count = ?, executed_at = ?
            WHERE id = ?
        """, (success_count, failed_count, now_ist().isoformat(), broadcast_id))
        
        await db.commit()
        
    finally:
        await release_db(db)


async def cancel_scheduled_broadcast(broadcast_id):
    """Cancel a scheduled broadcast (NEW)"""
    db = await get_db()
    try:
        await db.execute(
            "UPDATE scheduled_broadcasts SET status = 'cancelled' WHERE id = ? AND status = 'pending'",
            (broadcast_id,)
        )
        await db.commit()
        
        # Check if it was actually cancelled
        async with db.execute(
            "SELECT status FROM scheduled_broadcasts WHERE id = ?",
            (broadcast_id,)
        ) as cursor:
            row = await cursor.fetchone()
            return row['status'] == 'cancelled' if row else False
        
    finally:
        await release_db(db)


async def list_scheduled_broadcasts(admin_id=None, status='pending'):
    """List scheduled broadcasts (NEW)"""
    db = await get_db()
    try:
        if admin_id:
            query = "SELECT * FROM scheduled_broadcasts WHERE created_by = ? AND status = ? ORDER BY scheduled_time DESC LIMIT 20"
            params = (admin_id, status)
        else:
            query = "SELECT * FROM scheduled_broadcasts WHERE status = ? ORDER BY scheduled_time DESC LIMIT 20"
            params = (status,)
        
        async with db.execute(query, params) as cursor:
            broadcasts = []
            async for row in cursor:
                broadcasts.append(dict(row))
            return broadcasts
        
    finally:
        await release_db(db)


async def scheduled_broadcast_worker(context):
    """Background worker to send scheduled broadcasts (NEW)"""
    while True:
        try:
            await asyncio.sleep(60)  # Check every minute
            
            pending = await get_pending_broadcasts()
            
            for broadcast in pending:
                try:
                    # Send the broadcast
                    db = await get_db()
                    try:
                        # Get user count
                        async with db.execute("SELECT COUNT(*) as count FROM users WHERE blocked = 0") as cursor:
                            total = (await cursor.fetchone())['count']
                        
                        success = 0
                        failed = 0
                        
                        # Get users
                        async with db.execute("SELECT user_id, silent_mode FROM users WHERE blocked = 0") as cursor:
                            users = await cursor.fetchall()
                        
                        settings = await get_bot_settings()
                        protect_content = settings.get('protect_content', False)
                        include_silent = broadcast['include_silent']
                        
                        for user in users:
                            user_id = user['user_id']
                            silent_mode = user['silent_mode']
                            
                            # Skip if silent mode and not including silent users
                            if not include_silent and silent_mode == "full":
                                continue
                            
                            try:
                                if broadcast['message_id'] and broadcast['from_chat_id']:
                                    await context.bot.copy_message(
                                        chat_id=user_id,
                                        from_chat_id=broadcast['from_chat_id'],
                                        message_id=broadcast['message_id'],
                                        protect_content=protect_content
                                    )
                                else:
                                    await context.bot.send_message(
                                        chat_id=user_id,
                                        text=broadcast['message_text'],
                                        parse_mode="HTML",
                                        protect_content=protect_content
                                    )
                                success += 1
                            except:
                                failed += 1
                            
                            await asyncio.sleep(0.03)  # Rate limiting
                        
                        # Mark as sent
                        await mark_broadcast_sent(broadcast['id'], success, failed)
                        
                        logging.info(f"[SCHEDULED] Broadcast {broadcast['id']} sent: {success} success, {failed} failed")
                        
                    finally:
                        await release_db(db)
                        
                except Exception as e:
                    logging.error(f"[SCHEDULED] Error sending broadcast {broadcast['id']}: {e}")
                    
        except Exception as e:
            logging.error(f"[SCHEDULED] Worker error: {e}")    

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”„ RETRY MECHANISM
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def retry_operation(operation_key, operation_func, max_retries=MAX_RETRIES):
    """Retry an operation with exponential backoff"""
    if operation_key in active_retries:
        logging.info(f"[RETRY] Operation {operation_key} already in progress, skipping")
        return None
    
    active_retries[operation_key] = True
    
    try:
        for attempt in range(max_retries):
            try:
                result = await operation_func()
                logging.info(f"[RETRY] Operation {operation_key} succeeded on attempt {attempt + 1}")
                return result
            except Exception as e:
                if attempt < max_retries - 1:
                    delay = RETRY_DELAY * (2 ** attempt)
                    logging.warning(f"[RETRY] Attempt {attempt + 1} failed for {operation_key}: {e}. Retrying in {delay}s...")
                    await asyncio.sleep(delay)
                else:
                    logging.error(f"[RETRY] All {max_retries} attempts failed for {operation_key}: {e}")
                    raise
    finally:
        active_retries.pop(operation_key, None)


async def send_with_retry(context, chat_id, text, **kwargs):
    """Send message with automatic retry and forced protect_content"""
    operation_key = f"send_{chat_id}_{hash(text)}"
    
    # ALWAYS get settings and apply protect_content
    settings = await get_bot_settings()
    
    # Force protect_content if enabled in settings
    if settings.get('protect_content'):
        kwargs['protect_content'] = True
    
    async def send_operation():
        return await context.bot.send_message(chat_id=chat_id, text=text, **kwargs)
    
    return await retry_operation(operation_key, send_operation)


async def edit_with_retry(query, text, **kwargs):
    """Edit message with automatic retry"""
    operation_key = f"edit_{query.message.chat_id}_{query.message.message_id}"
    
    async def edit_operation():
        return await query.edit_message_text(text=text, **kwargs)
    
    return await retry_operation(operation_key, edit_operation) 

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“¤ SEND VIDEO TASK WITH RETRY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def send_video_task(context, chat_id, file_id, caption):
    """Send video with retry mechanism, auto-delete, and protect content"""
    settings = await get_bot_settings()
    auto_delete_enabled = settings.get('auto_delete', True)
    auto_delete_seconds = settings.get('auto_delete_seconds', 60)
    protect_content = settings.get('protect_content', False)
    
    try:
        # Send waiting message WITH protect_content
        async def send_wait_msg():
            delete_text = f"Auto-deleting in {auto_delete_seconds}s" if auto_delete_enabled else "No auto-delete"
            return await context.bot.send_message(
                chat_id=chat_id, 
                text=f"â³ <b>Generating file...</b>\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n{delete_text}\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
                parse_mode="HTML",
                protect_content=protect_content  # Apply protect here
            )
        w = await retry_operation(f"wait_{chat_id}_{file_id}", send_wait_msg)
        
        # Get design settings and apply formatter if enabled
        design_settings = await get_design_settings()
        
        if design_settings.get('caption_design', True):
            # Apply beautiful UI design with selected template
            batch_name = extract_batch_name(caption)
            clean_caption = format_video_caption(caption, batch_name, design_settings)
        else:
            # Use original caption with HTML tag cleanup
            clean_caption = caption
            if caption:
                # Keep bold and italic tags, remove others
                clean_caption = re.sub(r'<(?!/?[bi]>)[^>]+>', '', caption)
        
        # Send document WITH protect_content
        async def send_doc():
            return await context.bot.send_document(
                chat_id=chat_id, 
                document=file_id, 
                caption=clean_caption,
                parse_mode="HTML",
                protect_content=protect_content  # Apply protect here
            )
        s = await retry_operation(f"doc_{chat_id}_{file_id}", send_doc)
        
        # Auto-delete if enabled
        if auto_delete_enabled:
            await asyncio.sleep(auto_delete_seconds)
            try:
                await context.bot.delete_message(chat_id, s.message_id)
                await context.bot.delete_message(chat_id, w.message_id)
            except:
                pass
    except Exception as e:
        logging.error(f"Error in send_video_task: {e}")
        try:
            await context.bot.send_message(
                chat_id=chat_id,
                text=format_error_message("Failed to send file after multiple attempts.\nPlease try again later."),
                parse_mode="HTML",
                protect_content=protect_content  # Apply protect here too
            )
        except:
            pass  

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ‘¥ USER MANAGEMENT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def ensure_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ensure user exists in database with all fields"""
    uid = update.effective_user.id
    first_name = update.effective_user.first_name or ""
    last_name = update.effective_user.last_name or ""
    full_name = f"{first_name} {last_name}".strip()
    if not full_name:
        full_name = "Unknown User"
    
    today = now_ist().date().isoformat()
    
    db = await get_db()
    try:
        # Check if user exists
        async with db.execute("SELECT * FROM users WHERE user_id = ?", (uid,)) as cursor:
            user = await cursor.fetchone()
        
        if not user:
            # Create new user
            await db.execute("""
                INSERT INTO users (
                    user_id, username, joined_at, usage_today, usage_date,
                    blocked, daily_limit, extra_granted, bonus_claimed_date,
                    silent_mode, total_downloads, last_active, search_count,
                    favorite_batch, is_sub_admin
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                uid, full_name, now_ist().isoformat(), 0, today,
                0, 5, 0, "", None, 0, now_ist().isoformat(), 0, None, 0
            ))
            await db.commit()
            
            await track_event("user_joined", uid)
            
            log_msg = format_message_header("NEW USER STARTED BOT", "ğŸ†•")
            log_msg += f"ğŸ‘¤ <b>ID:</b> <code>{uid}</code>\n"
            log_msg += f"ğŸ”— <b>Name:</b> {full_name}\n"
            log_msg += f"â° <b>Time:</b> {now_ist().strftime('%I:%M %p')}"
            log_msg += format_message_footer()
            
            try:
                await context.bot.send_message(chat_id=LOG_CHANNEL_ID, text=log_msg, parse_mode="HTML")
            except:
                pass
        else:
            # Update existing user
            user_dict = dict(user)
            if user_dict.get("usage_date") != today:
                await db.execute(
                    "UPDATE users SET usage_today = 0, usage_date = ?, username = ?, last_active = ? WHERE user_id = ?",
                    (today, full_name, now_ist().isoformat(), uid)
                )
                await db.commit()
            else:
                await db.execute(
                    "UPDATE users SET username = ?, last_active = ? WHERE user_id = ?",
                    (full_name, now_ist().isoformat(), uid)
                )
                await db.commit()
        
        # Fetch updated user data
        async with db.execute("SELECT * FROM users WHERE user_id = ?", (uid,)) as cursor:
            user_row = await cursor.fetchone()
            return dict(user_row)
    
    finally:
        await release_db(db)


async def get_user_by_id(user_id):
    """Get user data by ID"""
    db = await get_db()
    try:
        async with db.execute("SELECT * FROM users WHERE user_id = ?", (user_id,)) as cursor:
            user = await cursor.fetchone()
            return dict(user) if user else None
    finally:
        await release_db(db)   

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“¬ SUBSCRIPTION SYSTEM
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def subscribe_to_batch(user_id, batch_name):
    """Subscribe user to a batch"""
    db = await get_db()
    try:
        # Check if already subscribed
        async with db.execute(
            "SELECT id FROM subscriptions WHERE user_id = ? AND batch_name = ?",
            (user_id, batch_name)
        ) as cursor:
            existing = await cursor.fetchone()
        
        if existing:
            return False
        
        # Add subscription
        await db.execute(
            "INSERT INTO subscriptions (user_id, batch_name, subscribed_at, notification_enabled) VALUES (?, ?, ?, ?)",
            (user_id, batch_name, now_ist().isoformat(), 1)
        )
        
        # Update batch metadata
        async with db.execute(
            "SELECT subscribers FROM batch_metadata WHERE batch_name = ?",
            (batch_name,)
        ) as cursor:
            batch = await cursor.fetchone()
        
        if batch:
            await db.execute(
                "UPDATE batch_metadata SET subscribers = subscribers + 1 WHERE batch_name = ?",
                (batch_name,)
            )
        else:
            await db.execute(
                "INSERT INTO batch_metadata (batch_name, subscribers, total_videos, created_at) VALUES (?, ?, ?, ?)",
                (batch_name, 1, 0, now_ist().isoformat())
            )
        
        await db.commit()
        await track_event("batch_subscribed", user_id, {"batch": batch_name})
        return True
    
    finally:
        await release_db(db)


async def unsubscribe_from_batch(user_id, batch_name):
    """Unsubscribe user from a batch"""
    db = await get_db()
    try:
        # Check if subscribed
        async with db.execute(
            "SELECT id FROM subscriptions WHERE user_id = ? AND batch_name = ?",
            (user_id, batch_name)
        ) as cursor:
            existing = await cursor.fetchone()
        
        if not existing:
            return False
        
        # Remove subscription
        await db.execute(
            "DELETE FROM subscriptions WHERE user_id = ? AND batch_name = ?",
            (user_id, batch_name)
        )
        
        # Update batch metadata
        await db.execute(
            "UPDATE batch_metadata SET subscribers = MAX(0, subscribers - 1) WHERE batch_name = ?",
            (batch_name,)
        )
        
        await db.commit()
        await track_event("batch_unsubscribed", user_id, {"batch": batch_name})
        return True
    
    finally:
        await release_db(db)


async def get_user_subscriptions(user_id):
    """Get all subscriptions for a user"""
    db = await get_db()
    try:
        subscriptions = []
        async with db.execute(
            "SELECT batch_name FROM subscriptions WHERE user_id = ? AND notification_enabled = 1",
            (user_id,)
        ) as cursor:
            async for row in cursor:
                subscriptions.append(row['batch_name'])
        return subscriptions
    finally:
        await release_db(db)


async def notify_subscribers(batch_name, video_caption, context):
    """Notify all subscribers of a batch about new video"""
    db = await get_db()
    try:
        notified = 0
        failed = 0
        
        # Get all subscribers for this batch
        async with db.execute(
            """SELECT DISTINCT s.user_id, u.silent_mode 
               FROM subscriptions s 
               JOIN users u ON s.user_id = u.user_id 
               WHERE s.batch_name = ? AND s.notification_enabled = 1""",
            (batch_name,)
        ) as cursor:
            subscribers = await cursor.fetchall()
        
        settings = await get_bot_settings()
        protect_content = settings.get('protect_content', False)
        
        for sub in subscribers:
            user_id = sub['user_id']
            silent_mode = sub['silent_mode']
            
            # Skip if user is in full silent mode
            if silent_mode == "full":
                continue
            
            notification_text = format_message_header("NEW VIDEO ALERT!", "ğŸ””")
            notification_text += f"ğŸ“‚ <b>Batch:</b> {batch_name}\n"
            notification_text += f"ğŸ¬ <b>Title:</b> {video_caption[:50]}{'...' if len(video_caption) > 50 else ''}\n"
            notification_text += f"â° <b>Added:</b> Just now\n"
            notification_text += format_message_footer()
            notification_text += "\nğŸ’¡ You're subscribed to this batch!"
            
            try:
                await context.bot.send_message(
                    chat_id=user_id,
                    text=notification_text,
                    parse_mode="HTML",
                    protect_content=protect_content,
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("ğŸ  Open Bot", callback_data="home")],
                        [InlineKeyboardButton("ğŸ”• Unsubscribe", callback_data=f"unsub:{batch_name}")]
                    ])
                )
                notified += 1
                await track_event("notification_sent", user_id, {"batch": batch_name, "video": video_caption[:50]})
            except Exception as e:
                logging.error(f"Failed to notify user {user_id}: {e}")
                failed += 1
            
            await asyncio.sleep(0.1)
        
        logging.info(f"[NOTIFY] Batch '{batch_name}': {notified} notified, {failed} failed")
        return notified, failed
    
    finally:
        await release_db(db)   

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”• SILENT MODE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def set_silent_mode(user_id, mode):
    """Set silent mode for user"""
    db = await get_db()
    try:
        await db.execute(
            "UPDATE users SET silent_mode = ? WHERE user_id = ?",
            (mode, user_id)
        )
        await db.commit()
        await track_event("silent_mode_changed", user_id, {"mode": mode})
        return True
    finally:
        await release_db(db)


async def can_send_notification(user_id, notification_type="general"):
    """Check if notification can be sent to user"""
    db = await get_db()
    try:
        async with db.execute(
            "SELECT silent_mode FROM users WHERE user_id = ?",
            (user_id,)
        ) as cursor:
            user = await cursor.fetchone()
        
        if not user:
            return True
        
        silent_mode = user['silent_mode']
        
        if silent_mode == "full":
            return False
        elif silent_mode == "except_subscriptions":
            return notification_type == "subscription"
        
        return True
    finally:
        await release_db(db)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“š CATEGORIES SYSTEM
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def get_category_for_batch(batch_name):
    """Get category that contains this batch"""
    db = await get_db()
    try:
        async with db.execute(
            "SELECT category_name FROM category_batches WHERE batch_name = ?",
            (batch_name,)
        ) as cursor:
            result = await cursor.fetchone()
            return result['category_name'] if result else None
    finally:
        await release_db(db)


async def get_batches_in_category(category_name):
    """Get all batches in a category"""
    db = await get_db()
    try:
        batches = []
        async with db.execute(
            "SELECT batch_name FROM category_batches WHERE category_name = ?",
            (category_name,)
        ) as cursor:
            async for row in cursor:
                batches.append(row['batch_name'])
        return batches
    finally:
        await release_db(db)


async def get_uncategorized_batches():
    """Get batches that don't belong to any category"""
    db = await get_db()
    try:
        # Get all unique batch names from videos
        all_batches = set()
        async with db.execute("SELECT DISTINCT batch FROM videos") as cursor:
            async for row in cursor:
                all_batches.add(row['batch'])
        
        # Get categorized batches
        categorized = set()
        async with db.execute("SELECT DISTINCT batch_name FROM category_batches") as cursor:
            async for row in cursor:
                categorized.add(row['batch_name'])
        
        return list(all_batches - categorized)
    finally:
        await release_db(db)


async def get_all_categories():
    """Get all categories with their emojis"""
    db = await get_db()
    try:
        categories = {}
        async with db.execute("SELECT category_name, emoji FROM categories ORDER BY category_name") as cursor:
            async for row in cursor:
                categories[row['category_name']] = row['emoji']
        return categories
    finally:
        await release_db(db)


async def get_category_emoji(category_name):
    """Get emoji for a specific category"""
    db = await get_db()
    try:
        async with db.execute(
            "SELECT emoji FROM categories WHERE category_name = ?",
            (category_name,)
        ) as cursor:
            row = await cursor.fetchone()
            return row['emoji'] if row else 'ğŸ“š'
    finally:
        await release_db(db)  

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“¢ NON-BLOCKING BROADCAST SYSTEM
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def broadcast_worker(context):
    """Background worker that processes broadcast queue"""
    global broadcast_active
    
    while True:
        try:
            broadcast_data = await broadcast_queue.get()
            
            if broadcast_data is None:
                break
            
            broadcast_active = True
            message = broadcast_data['message']
            message_id = broadcast_data.get('message_id')
            from_chat_id = broadcast_data.get('from_chat_id')
            admin_id = broadcast_data.get('admin_id')
            include_silent = broadcast_data.get('include_silent', False)
            
            db = await get_db()
            try:
                # Get user count
                async with db.execute("SELECT COUNT(*) as count FROM users WHERE blocked = 0") as cursor:
                    row = await cursor.fetchone()
                    total = row['count']
                
                success = 0
                failed = 0
                skipped = 0
                
                logging.info(f"[BROADCAST] Starting broadcast to {total} users (include_silent={include_silent})...")
                
                try:
                    settings = await get_bot_settings()
                    protect_content = settings.get('protect_content', False)
                    
                    progress_msg = await context.bot.send_message(
                        admin_id,
                        format_message_header("BROADCAST STARTED", "ğŸ“¢") +
                        f"ğŸ“Š <b>Total Users:</b> {total}\nâ³ Processing..." +
                        format_message_footer(),
                        parse_mode="HTML",
                        protect_content=False
                    )
                except:
                    progress_msg = None
                
                batch_size = 20
                
                # Get users
                async with db.execute(
                    "SELECT user_id, silent_mode FROM users WHERE blocked = 0"
                ) as cursor:
                    users = await cursor.fetchall()
                
                for i in range(0, len(users), batch_size):
                    batch = users[i:i+batch_size]
                    tasks = []
                    
                    for user in batch:
                        user_id = user['user_id']
                        silent_mode = user['silent_mode']
                        
                        # Skip if silent mode is full and not including silent users
                        if not include_silent and silent_mode == "full":
                            skipped += 1
                            continue
                        
                        tasks.append(send_broadcast_message(
                            context, user_id, message, message_id, 
                            from_chat_id, protect_content
                        ))
                    
                    results = await asyncio.gather(*tasks, return_exceptions=True)
                    
                    for result in results:
                        if isinstance(result, Exception):
                            failed += 1
                        elif result:
                            success += 1
                        else:
                            failed += 1
                    
                    if progress_msg and (i + batch_size) % 100 == 0:
                        try:
                            progress_text = format_message_header("BROADCAST IN PROGRESS", "ğŸ“¢")
                            progress_text += f"âœ… <b>Sent:</b> {success}\n"
                            progress_text += f"âŒ <b>Failed:</b> {failed}\n"
                            progress_text += f"ğŸ”• <b>Skipped:</b> {skipped}\n"
                            progress_text += f"ğŸ“Š <b>Progress:</b> {min(i+batch_size, total)}/{total}"
                            progress_text += format_message_footer()
                            
                            await context.bot.edit_message_text(
                                progress_text,
                                chat_id=admin_id,
                                message_id=progress_msg.message_id,
                                parse_mode="HTML"
                            )
                        except:
                            pass
                    
                    await asyncio.sleep(BROADCAST_RATE_LIMIT * batch_size)
                
                report_text = format_message_header("BROADCAST COMPLETED", "ğŸ“¢")
                report_text += f"âœ… <b>Success:</b> {success}\n"
                report_text += f"âŒ <b>Failed:</b> {failed}\n"
                report_text += f"ğŸ”• <b>Skipped (Silent):</b> {skipped}\n"
                report_text += f"ğŸ“Š <b>Total:</b> {total}"
                report_text += format_message_footer()
                
                try:
                    if progress_msg:
                        await context.bot.edit_message_text(
                            report_text,
                            chat_id=admin_id,
                            message_id=progress_msg.message_id,
                            parse_mode="HTML"
                        )
                    else:
                        await context.bot.send_message(admin_id, report_text, parse_mode="HTML")
                except:
                    pass
                
                logging.info(f"[BROADCAST] Completed: {success} success, {failed} failed, {skipped} skipped")
            
            finally:
                await release_db(db)
                broadcast_active = False
            
        except Exception as e:
            logging.error(f"[BROADCAST] Worker error: {e}")
            broadcast_active = False


async def send_broadcast_message(context, user_id, message, message_id=None, from_chat_id=None, protect_content=False):
    """Send individual broadcast message with protect_content support"""
    try:
        if message_id and from_chat_id:
            # When copying a message, protect_content is applied
            await context.bot.copy_message(
                chat_id=user_id,
                from_chat_id=from_chat_id,
                message_id=message_id,
                protect_content=protect_content
            )
        else:
            await context.bot.send_message(
                chat_id=user_id,
                text=message,
                parse_mode="HTML",
                protect_content=protect_content
            )
        return True
    except Exception as e:
        logging.error(f"[BROADCAST] Failed to send to {user_id}: {e}")
        return False 

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš¡ HIGH-PERFORMANCE USER REQUEST HANDLER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def user_request_worker(context):
    """Worker that processes user requests"""
    while True:
        try:
            request_data = await user_request_queue.get()
            
            if request_data is None:
                break
            
            handler = request_data['handler']
            args = request_data.get('args', [])
            kwargs = request_data.get('kwargs', {})
            
            try:
                await asyncio.wait_for(
                    handler(*args, **kwargs),
                    timeout=USER_REQUEST_TIMEOUT
                )
            except asyncio.TimeoutError:
                logging.error(f"[REQUEST] Timeout for handler {handler.__name__}")
                try:
                    if 'update' in kwargs:
                        update = kwargs['update']
                        await context.bot.send_message(
                            update.effective_chat.id,
                            format_error_message("Request timeout. Please try again."),
                            parse_mode="HTML"
                        )
                except:
                    pass
            except Exception as e:
                logging.error(f"[REQUEST] Error in handler {handler.__name__}: {e}")
            
            user_request_queue.task_done()
            
        except Exception as e:
            logging.error(f"[REQUEST] Worker error: {e}")


async def queue_user_request(handler, *args, **kwargs):
    """Queue a user request for processing"""
    await user_request_queue.put({
        'handler': handler,
        'args': args,
        'kwargs': kwargs
    })


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”§ TASK POOL MANAGEMENT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def start_worker_pool(context):
    """Start pool of workers"""
    global task_pool
    
    # Broadcast worker
    task_pool.append(asyncio.create_task(broadcast_worker(context)))
    
    # User request workers
    for i in range(MAX_CONCURRENT_WORKERS):
        task_pool.append(asyncio.create_task(user_request_worker(context)))
    
    # Scheduled broadcast worker (NEW)
    task_pool.append(asyncio.create_task(scheduled_broadcast_worker(context)))
    
    logging.info(f"[WORKERS] Started {len(task_pool)} workers")


async def stop_worker_pool():
    """Stop all workers gracefully"""
    global task_pool
    
    await broadcast_queue.put(None)
    for _ in range(MAX_CONCURRENT_WORKERS):
        await user_request_queue.put(None)
    
    if task_pool:
        await asyncio.gather(*task_pool, return_exceptions=True)
        task_pool = []
    
    logging.info("[WORKERS] All workers stopped")


async def guaranteed_response(update, context, handler_func):
    """Wrapper that guarantees user gets a response"""
    user_id = update.effective_user.id
    
    try:
        await handler_func(update, context)
    except Exception as e:
        logging.error(f"[GUARANTEED_RESPONSE] Handler failed for user {user_id}: {e}")
        
        try:
            error_msg = format_error_message(
                "Something went wrong!\nPlease try again or contact admin."
            )
            
            if update.message:
                await update.message.reply_text(error_msg, parse_mode="HTML")
            elif update.callback_query:
                await update.callback_query.answer("âŒ Error occurred", show_alert=True)
                try:
                    await update.callback_query.message.reply_text(error_msg, parse_mode="HTML")
                except:
                    pass
        except Exception as fallback_error:
            logging.error(f"[GUARANTEED_RESPONSE] Fallback also failed: {fallback_error}")     

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¨ UI BUILDERS - MAIN & CATEGORY MENUS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def build_main_menu(page=0):
    """Build main menu with categories"""
    categories = await get_all_categories()
    cat_list = sorted(categories.keys())
    total_pages = (len(cat_list) + 9) // 10
    cats_page = cat_list[page*10:(page+1)*10]
    
    kb = []
    for cat in cats_page:
        emoji = categories[cat]
        kb.append([InlineKeyboardButton(f"{emoji} {cat}", callback_data=f"category:{cat}:0")])
    
    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton("â¬…ï¸ Prev", callback_data=f"main:{page-1}"))
    if page + 1 < total_pages:
        nav.append(InlineKeyboardButton("Next â¡ï¸", callback_data=f"main:{page+1}"))
    if nav:
        kb.append(nav)
    
    search_emoji = await get_emoji('ui', 'search', 'ğŸ”')
    subs_emoji = await get_emoji('ui', 'subscriptions', 'ğŸ“¬')
    stats_emoji = await get_emoji('ui', 'stats', 'ğŸ“Š')
    
    kb.append([InlineKeyboardButton(f"{search_emoji} Search Video", callback_data="search_start")])
    kb.append([
        InlineKeyboardButton(f"{subs_emoji} My Subscriptions", callback_data="my_subscriptions"),
        InlineKeyboardButton(f"{stats_emoji} My Stats", callback_data="my_stats")
    ])
    kb.append([InlineKeyboardButton("ğŸ“ Contact Admin", callback_data="contact_admin")])
    
    return kb


async def build_category_menu(category_name, page=0):
    """Build menu showing batches in a category"""
    batches = await get_batches_in_category(category_name)
    
    if not batches:
        home_emoji = await get_emoji('ui', 'home', 'ğŸ ')
        return [[InlineKeyboardButton(f"{home_emoji} Home Menu", callback_data="home")]]
    
    db = await get_db()
    try:
        kb = []
        batch_emoji = await get_emoji('ui', 'batch', 'ğŸ“‚')
        
        for batch in batches[page*10:(page+1)*10]:
            async with db.execute(
                "SELECT COUNT(*) as count FROM videos WHERE batch = ?",
                (batch,)
            ) as cursor:
                row = await cursor.fetchone()
                video_count = row['count']
            
            kb.append([InlineKeyboardButton(
                f"{batch_emoji} {batch} ({video_count} videos)", 
                callback_data=f"batch:{batch}:0:init"
            )])
        
        nav = []
        if page > 0:
            nav.append(InlineKeyboardButton("â¬…ï¸ Prev", callback_data=f"category:{category_name}:{page-1}"))
        if (page+1)*10 < len(batches):
            nav.append(InlineKeyboardButton("Next â¡ï¸", callback_data=f"category:{category_name}:{page+1}"))
        if nav:
            kb.append(nav)
        
        home_emoji = await get_emoji('ui', 'home', 'ğŸ ')
        kb.append([InlineKeyboardButton(f"{home_emoji} Home Menu", callback_data="home")])
        
        return kb
    finally:
        await release_db(db)


async def build_batch_menu(batch_name, page=0):
    """Build menu for specific batch"""
    db = await get_db()
    try:
        async with db.execute(
            "SELECT msg_id, caption, file_type FROM videos WHERE batch = ? ORDER BY msg_id DESC",
            (batch_name,)
        ) as cursor:
            batch_vids = await cursor.fetchall()
        
        kb = []
        for v in batch_vids[page*10:(page+1)*10]:
            emoji = await get_file_emoji(v['caption'], v['file_type'])
            kb.append([InlineKeyboardButton(
                f"{emoji} {strip_html(v['caption'][:35])}", 
                callback_data=f"video:{v['msg_id']}"
            )])
        
        nav = []
        if page > 0:
            nav.append(InlineKeyboardButton("â¬…ï¸ Prev", callback_data=f"batch:{batch_name}:{page-1}"))
        if (page+1)*10 < len(batch_vids):
            nav.append(InlineKeyboardButton("Next â¡ï¸", callback_data=f"batch:{batch_name}:{page+1}"))
        if nav:
            kb.append(nav)
        
        kb.append([InlineKeyboardButton("ğŸ•’ Recently Added", callback_data=f"recent:{batch_name}:0")])
        
        home_emoji = await get_emoji('ui', 'home', 'ğŸ ')
        kb.append([InlineKeyboardButton(f"{home_emoji} Home Menu", callback_data="home")])
        
        return kb
    finally:
        await release_db(db)


async def build_recent_menu(batch_name, page=0):
    """Build menu for recent videos in a batch"""
    db = await get_db()
    try:
        async with db.execute(
            "SELECT msg_id, caption, file_type FROM videos WHERE batch = ? ORDER BY msg_id DESC LIMIT 20",
            (batch_name,)
        ) as cursor:
            recent_vids = await cursor.fetchall()
        
        kb = []
        for v in recent_vids[page*10:(page+1)*10]:
            emoji = await get_file_emoji(v['caption'], v['file_type'])
            kb.append([InlineKeyboardButton(
                f"{emoji} {strip_html(v['caption'][:35])}", 
                callback_data=f"video:{v['msg_id']}"
            )])
        
        nav = []
        if page > 0:
            nav.append(InlineKeyboardButton("â¬…ï¸ Prev", callback_data=f"recent:{batch_name}:{page-1}"))
        if (page+1)*10 < len(recent_vids):
            nav.append(InlineKeyboardButton("Next â¡ï¸", callback_data=f"recent:{batch_name}:{page+1}"))
        if nav:
            kb.append(nav)
        
        kb.append([InlineKeyboardButton("ğŸ”™ Back to Batch", callback_data=f"batch:{batch_name}:0")])
        
        home_emoji = await get_emoji('ui', 'home', 'ğŸ ')
        kb.append([InlineKeyboardButton(f"{home_emoji} Home", callback_data="home")])
        
        return kb
    finally:
        await release_db(db)


async def build_search_results_menu(query, results, page=0, sort_by="relevance"):
    """Build search results menu with sorting options"""
    if sort_by == "date":
        results = sorted(results, key=lambda v: v['msg_id'], reverse=True)
    elif sort_by == "name":
        results = sorted(results, key=lambda v: v['caption'].lower())
    
    kb = []
    for v in results[page*10:(page+1)*10]:
        emoji = await get_file_emoji(v['caption'], v['file_type'])
        kb.append([InlineKeyboardButton(
            f"{emoji} {strip_html(v['caption'][:35])}", 
            callback_data=f"video:{v['msg_id']}"
        )])
    
    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton("â¬…ï¸ Prev", callback_data=f"search_page:{query}:{page-1}:{sort_by}"))
    if (page+1)*10 < len(results):
        nav.append(InlineKeyboardButton("Next â¡ï¸", callback_data=f"search_page:{query}:{page+1}:{sort_by}"))
    if nav:
        kb.append(nav)
    
    sort_buttons = []
    if sort_by != "relevance":
        sort_buttons.append(InlineKeyboardButton("ğŸ¯ Relevance", callback_data=f"sort_search:{query}:0:relevance"))
    if sort_by != "date":
        sort_buttons.append(InlineKeyboardButton("ğŸ“… Recent", callback_data=f"sort_search:{query}:0:date"))
    if sort_by != "name":
        sort_buttons.append(InlineKeyboardButton("ğŸ”¤ Name", callback_data=f"sort_search:{query}:0:name"))
    
    if sort_buttons:
        kb.append(sort_buttons)
    
    home_emoji = await get_emoji('ui', 'home', 'ğŸ ')
    kb.append([InlineKeyboardButton(f"{home_emoji} Home", callback_data="home")])
    
    return kb   

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›ï¸ ADMIN PANEL UI BUILDERS - PART 1
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def build_admin_panel_main():
    """Build main admin panel with reorganized structure"""
    kb = [
        [InlineKeyboardButton("ğŸ“š Category Management", callback_data="admin_panel:category_mgmt")],
        [InlineKeyboardButton("ğŸ“‚ Batch Management", callback_data="admin_panel:batch_mgmt")],
        [InlineKeyboardButton("ğŸ‘¥ User Management", callback_data="admin_panel:user_mgmt")],
        [InlineKeyboardButton("âš™ï¸ System & Settings", callback_data="admin_panel:system_settings")],
        [InlineKeyboardButton("ğŸ“Š Statistics & Reports", callback_data="admin_panel:stats")],
        [InlineKeyboardButton("ğŸ—‘ï¸ Database Management", callback_data="admin_panel:database_mgmt")],
        [InlineKeyboardButton("ğŸ†• NEW: Enhanced Features", callback_data="admin_panel:enhanced_features")],
        [InlineKeyboardButton("ğŸ”™ Close Panel", callback_data="admin_panel:close")]
    ]
    return kb


async def build_enhanced_features_menu():
    """Build enhanced features menu (NEW)"""
    kb = [
        [InlineKeyboardButton("ğŸ‘¥ Bulk User Management", callback_data="admin_enhanced:bulk_users")],
        [InlineKeyboardButton("ğŸ“¤ Export Categories", callback_data="admin_enhanced:export_cats")],
        [InlineKeyboardButton("ğŸ“¥ Import Categories", callback_data="admin_enhanced:import_cats")],
        [InlineKeyboardButton("ğŸ“Š Batch Statistics", callback_data="admin_enhanced:batch_stats")],
        [InlineKeyboardButton("ğŸ”¥ Activity Heatmap", callback_data="admin_enhanced:heatmap")],
        [InlineKeyboardButton("â° Scheduled Broadcasts", callback_data="admin_enhanced:scheduled")],
        [InlineKeyboardButton("ğŸ”™ Back to Admin Panel", callback_data="admin_panel:main")]
    ]
    return kb


async def build_system_settings_menu():
    """Build consolidated system & settings menu"""
    kb = [
        [InlineKeyboardButton("ğŸ¨ Design Settings", callback_data="admin_panel:design_settings")],
        [InlineKeyboardButton("ğŸ˜€ Emoji Settings", callback_data="admin_panel:emoji_settings")],
        [InlineKeyboardButton("ğŸ¬ Animation Settings", callback_data="admin_panel:animation_settings")],
        [InlineKeyboardButton("ğŸ”’ Bot Settings", callback_data="admin_panel:settings")],
        [InlineKeyboardButton("ğŸ“¢ Broadcast System", callback_data="admin_panel:broadcast_menu")],
        [InlineKeyboardButton("ğŸ’¾ Backup & Recovery", callback_data="admin_panel:backup")],
        [InlineKeyboardButton("ğŸ”™ Back to Admin Panel", callback_data="admin_panel:main")]
    ]
    return kb


async def build_design_settings_menu():
    """Build design settings menu"""
    settings = await get_design_settings()
    full_settings = await get_bot_settings()
    
    design_status = "âœ… ON" if settings.get('caption_design') else "âŒ OFF"
    footer_status = "âœ… ON" if settings.get('auto_footer') else "âŒ OFF"
    footer_name = settings.get('footer_name', 'Team Bot')
    
    # Get current template
    current_template = full_settings.get('caption_template', 'classic_box')
    template_name = CAPTION_TEMPLATES.get(current_template, {}).get('name', 'Classic Box')
    
    kb = [
        [InlineKeyboardButton(f"ğŸ¨ Caption Design: {design_status}", callback_data="admin_design:toggle_design")],
        [InlineKeyboardButton(f"ğŸ“‘ Template: {template_name}", callback_data="admin_design:templates")],
        [InlineKeyboardButton(f"ğŸ‘¤ Auto Footer: {footer_status}", callback_data="admin_design:toggle_footer")],
        [InlineKeyboardButton(f"âœï¸ Footer Name: {footer_name}", callback_data="admin_design:change_name")],
        [InlineKeyboardButton("ğŸ” Preview Design", callback_data="admin_design:preview")],
        [InlineKeyboardButton("ğŸ”™ Back to System & Settings", callback_data="admin_panel:system_settings")]
    ]
    return kb


async def build_caption_template_menu():
    """Build caption template selection menu (NEW)"""
    settings = await get_bot_settings()
    current_template = settings.get('caption_template', 'classic_box')
    
    kb = []
    
    for template_id, template_info in CAPTION_TEMPLATES.items():
        is_current = "âœ… " if template_id == current_template else ""
        kb.append([InlineKeyboardButton(
            f"{is_current}{template_info['name']}",
            callback_data=f"admin_template:select:{template_id}"
        )])
    
    kb.append([InlineKeyboardButton("ğŸ” Preview All", callback_data="admin_template:preview_all")])
    kb.append([InlineKeyboardButton("ğŸ”™ Back to Design Settings", callback_data="admin_panel:design_settings")])
    
    return kb


async def build_animation_settings_menu():
    """Build animation settings menu (UPDATED - Added start & contact)"""
    settings = await get_animation_settings()
    
    global_status = "âœ… ON" if settings.get('global_enabled') else "âŒ OFF"
    
    kb = [
        [InlineKeyboardButton(f"ğŸ­ Global Animations: {global_status}", callback_data="admin_anim:toggle_global")],
    ]
    
    anim_names = {
        'loading': 'Loading',
        'processing': 'Processing', 
        'search': 'Search',
        'stats': 'Stats',
        'start': 'Start Command',
        'contact': 'Contact Admin'
    }
    
    for anim_type, display_name in anim_names.items():
        anim = settings.get(anim_type, {})
        emoji = anim.get('emoji', 'ğŸš€')
        duration = anim.get('duration', 1.5)
        enabled = anim.get('enabled', True)
        status = "âœ…" if enabled else "âŒ"
        
        kb.append([InlineKeyboardButton(
            f"{emoji} {display_name}: {status} ({duration}s)",
            callback_data=f"admin_anim:edit:{anim_type}"
        )])
    
    kb.append([InlineKeyboardButton("ğŸ”™ Back to System & Settings", callback_data="admin_panel:system_settings")])
    
    return kb


async def build_animation_edit_menu(anim_type):
    """Build edit menu for specific animation"""
    settings = await get_animation_settings()
    anim = settings.get(anim_type, {})
    
    enabled = anim.get('enabled', True)
    status = "âœ… ON" if enabled else "âŒ OFF"
    
    kb = [
        [InlineKeyboardButton("ğŸ¨ Change Emoji", callback_data=f"admin_anim:change_emoji:{anim_type}")],
        [InlineKeyboardButton("â±ï¸ Change Duration", callback_data=f"admin_anim:change_duration:{anim_type}")],
        [InlineKeyboardButton(f"ğŸ”„ Toggle: {status}", callback_data=f"admin_anim:toggle:{anim_type}")],
        [InlineKeyboardButton("ğŸ”™ Back to Animation Settings", callback_data="admin_panel:animation_settings")]
    ]
    
    return kb


async def build_emoji_type_selection():
    """Build emoji type selection menu"""
    kb = [
        [InlineKeyboardButton("ğŸ¬ File Type Emojis", callback_data="emoji_select:file_types")],
        [InlineKeyboardButton("ğŸ¨ UI Element Emojis", callback_data="emoji_select:ui_elements")],
        [InlineKeyboardButton("ğŸ“š Category Emojis", callback_data="emoji_select:categories")],
        [InlineKeyboardButton("ğŸ¬ Animation Emojis", callback_data="emoji_select:animations")],
        [InlineKeyboardButton("ğŸ”„ Reset All to Default", callback_data="emoji_select:reset_all")],
        [InlineKeyboardButton("ğŸ”™ Back to System & Settings", callback_data="admin_panel:system_settings")]
    ]
    return kb


async def build_emoji_item_selection(emoji_type):
    """Build selection menu for specific emoji type items"""
    db = await get_db()
    kb = []
    
    try:
        if emoji_type == "file_types":
            items = [('video', 'â–¶ï¸'), ('document', 'ğŸ“„'), ('pdf', 'ğŸ“•'), ('zip', 'ğŸ“¦'), ('txt', 'ğŸ“„')]
            for item, default_emoji in items:
                async with db.execute(
                    "SELECT emoji FROM emoji_settings WHERE setting_type = 'file_type' AND setting_key = ?",
                    (item,)
                ) as cursor:
                    row = await cursor.fetchone()
                    current_emoji = row['emoji'] if row else default_emoji
                
                kb.append([InlineKeyboardButton(
                    f"{current_emoji} {item.title()} (Current: {current_emoji})",
                    callback_data=f"emoji_item:file_type:{item}"
                )])
        
        elif emoji_type == "ui_elements":
            items = [('home', 'ğŸ '), ('search', 'ğŸ”'), ('stats', 'ğŸ“Š'), ('subscriptions', 'ğŸ“¬'), ('category', 'ğŸ“š'), ('batch', 'ğŸ“‚')]
            for item, default_emoji in items:
                async with db.execute(
                    "SELECT emoji FROM emoji_settings WHERE setting_type = 'ui' AND setting_key = ?",
                    (item,)
                ) as cursor:
                    row = await cursor.fetchone()
                    current_emoji = row['emoji'] if row else default_emoji
                
                kb.append([InlineKeyboardButton(
                    f"{current_emoji} {item.title()} (Current: {current_emoji})",
                    callback_data=f"emoji_item:ui:{item}"
                )])
        
        elif emoji_type == "categories":
            async with db.execute(
                "SELECT category_name, emoji FROM categories ORDER BY category_name"
            ) as cursor:
                async for row in cursor:
                    cat_name = row['category_name']
                    cat_emoji = row['emoji']
                    kb.append([InlineKeyboardButton(
                        f"{cat_emoji} {cat_name} (Current: {cat_emoji})",
                        callback_data=f"emoji_item:category:{cat_name}"
                    )])
        
        elif emoji_type == "animations":
            items = [('loading', 'ğŸš€'), ('processing', 'â³'), ('search', 'ğŸ”'), ('stats', 'ğŸ“Š'), ('start', 'ğŸ¤–'), ('contact', 'ğŸ“')]
            for item, default_emoji in items:
                async with db.execute(
                    "SELECT emoji FROM emoji_settings WHERE setting_type = 'animation' AND setting_key = ?",
                    (item,)
                ) as cursor:
                    row = await cursor.fetchone()
                    current_emoji = row['emoji'] if row else default_emoji
                
                kb.append([InlineKeyboardButton(
                    f"{current_emoji} {item.title()} (Current: {current_emoji})",
                    callback_data=f"emoji_item:animation:{item}"
                )])
        
        kb.append([InlineKeyboardButton("ğŸ”™ Back", callback_data="admin_panel:emoji_settings")])
        
        return kb
    finally:
        await release_db(db)


def build_batch_management_menu():
    """Build batch management menu"""
    kb = [
        [InlineKeyboardButton("ğŸ—‘ï¸ Delete Batch", callback_data="admin_batch:delete_interactive")],
        [InlineKeyboardButton("ğŸ“¦ Assign Batch", callback_data="admin_batch:assign_interactive")],
        [InlineKeyboardButton("âŒ Unassign Batch", callback_data="admin_batch:unassign_interactive")],
        [InlineKeyboardButton("ğŸ“‹ List All Batches", callback_data="admin_batch:list")],
        [InlineKeyboardButton("ğŸ“Š Batch Statistics", callback_data="admin_batch:stats")],
        [InlineKeyboardButton("ğŸ”™ Back to Admin Panel", callback_data="admin_panel:main")]
    ]
    return kb


def build_category_management_menu():
    """Build category management menu"""
    kb = [
        [InlineKeyboardButton("â• Add Category", callback_data="admin_cat:add_interactive")],
        [InlineKeyboardButton("âœï¸ Rename Category", callback_data="admin_cat:rename_interactive")],
        [InlineKeyboardButton("ğŸ—‘ï¸ Delete Category", callback_data="admin_cat:delete_interactive")],
        [InlineKeyboardButton("ğŸ“‹ List Categories", callback_data="admin_cat:list")],
        [InlineKeyboardButton("ğŸ“‚ View Uncategorized", callback_data="admin_cat:uncategorized")],
        [InlineKeyboardButton("ğŸ”™ Back to Admin Panel", callback_data="admin_panel:main")]
    ]
    return kb


def build_user_management_menu():
    """Build user management menu"""
    kb = [
        [InlineKeyboardButton("ğŸ” Search User Info", callback_data="admin_user:search")],
        [InlineKeyboardButton("ğŸš« Block User", callback_data="admin_user:block_menu")],
        [InlineKeyboardButton("âœ… Unblock User", callback_data="admin_user:unblock_menu")],
        [InlineKeyboardButton("ğŸ’ Grant Extra Downloads", callback_data="admin_user:grant_menu")],
        [InlineKeyboardButton("ğŸ“‰ Revoke Downloads", callback_data="admin_user:revoke_menu")],
        [InlineKeyboardButton("ğŸ”„ Reset User Usage", callback_data="admin_user:reset_menu")],
        [InlineKeyboardButton("ğŸ Grant All Unlimited", callback_data="admin_user:grantall")],
        [InlineKeyboardButton("ğŸ›‘ Stop Grant All", callback_data="admin_user:stopgrantall")],
        [InlineKeyboardButton("ğŸ‘¤ Add Sub-Admin", callback_data="admin_user:addadmin")],
        [InlineKeyboardButton("âŒ Remove Sub-Admin", callback_data="admin_user:removeadmin")],
        [InlineKeyboardButton("ğŸ”™ Back to Admin Panel", callback_data="admin_panel:main")]
    ]
    return kb


def build_stats_menu():
    """Build statistics menu"""
    kb = [
        [InlineKeyboardButton("ğŸ“Š System Statistics", callback_data="admin_stats:system")],
        [InlineKeyboardButton("ğŸ“„ User Report (TXT)", callback_data="admin_stats:user_txt")],
        [InlineKeyboardButton("ğŸ¬ Video Report (TXT)", callback_data="admin_stats:video_txt")],
        [InlineKeyboardButton("ğŸ”™ Back to Admin Panel", callback_data="admin_panel:main")]
    ]
    return kb


def build_broadcast_menu():
    """Build broadcast menu"""
    kb = [
        [InlineKeyboardButton("ğŸ“¢ Send Broadcast", callback_data="admin_broadcast:send")],
        [InlineKeyboardButton("ğŸ“Š Broadcast Status", callback_data="admin_broadcast:status")],
        [InlineKeyboardButton("ğŸ”™ Back to Admin Panel", callback_data="admin_panel:main")]
    ]
    return kb


async def build_settings_menu():
    """Build settings menu with current values (UPDATED - Added time selection)"""
    settings = await get_bot_settings()
    protect_status = "ğŸ”’ ON" if settings.get('protect_content') else "ğŸ”“ OFF"
    auto_delete_status = "âœ… ON" if settings.get('auto_delete') else "âŒ OFF"
    auto_delete_sec = settings.get('auto_delete_seconds', 60)
    
    kb = [
        [InlineKeyboardButton(f"ğŸ”’ Protect Content: {protect_status}", callback_data="admin_settings:toggle_protect")],
        [InlineKeyboardButton(f"ğŸ—‘ï¸ Auto Delete: {auto_delete_status}", callback_data="admin_settings:toggle_autodelete")],
        [InlineKeyboardButton(f"â±ï¸ Auto Delete Time: {auto_delete_sec}s", callback_data="admin_settings:change_time")],
        [InlineKeyboardButton("ğŸ”™ Back to System & Settings", callback_data="admin_panel:system_settings")]
    ]
    return kb


def build_database_mgmt_menu():
    """Build database management menu"""
    kb = [
        [InlineKeyboardButton("ğŸ—‘ï¸ Delete Users", callback_data="admin_db:delete_users")],
        [InlineKeyboardButton("ğŸ—‘ï¸ Delete Videos", callback_data="admin_db:delete_videos")],
        [InlineKeyboardButton("ğŸ—‘ï¸ Delete Categories", callback_data="admin_db:delete_categories")],
        [InlineKeyboardButton("ğŸ—‘ï¸ Delete Analytics", callback_data="admin_db:delete_analytics")],
        [InlineKeyboardButton("âš ï¸ Clear All Data", callback_data="admin_db:clear_all")],
        [InlineKeyboardButton("ğŸ”™ Back to Admin Panel", callback_data="admin_panel:main")]
    ]
    return kb


def build_backup_menu():
    """Build backup menu"""
    kb = [
        [InlineKeyboardButton("ğŸ’¾ Backup Now", callback_data="admin_backup:now")],
        [InlineKeyboardButton("ğŸ“¥ Send Database File", callback_data="admin_backup:send")],
        [InlineKeyboardButton("â™»ï¸ Recovery Mode", callback_data="admin_backup:recovery")],
        [InlineKeyboardButton("ğŸ”™ Back to System & Settings", callback_data="admin_panel:system_settings")]
    ]
    return kb


async def build_category_selection_buttons(action_prefix):
    """Build category selection buttons for operations"""
    categories = await get_all_categories()
    kb = []
    
    for cat_name, emoji in sorted(categories.items()):
        kb.append([InlineKeyboardButton(
            f"{emoji} {cat_name}",
            callback_data=f"{action_prefix}:{cat_name}"
        )])
    
    kb.append([InlineKeyboardButton("âŒ Cancel", callback_data="admin_panel:category_mgmt")])
    return kb


async def build_batch_selection_buttons(category_name, action_prefix, allow_multiple=False):
    """Build batch selection buttons for operations (UPDATED - With checkmarks)"""
    batches = await get_batches_in_category(category_name)
    
    db = await get_db()
    try:
        kb = []
        
        # Get current user's selections if any
        user_key = f"{action_prefix}:selections"
        user_selections = selected_items.get(user_key, set())
        
        for batch in batches:
            async with db.execute(
                "SELECT COUNT(*) as count FROM videos WHERE batch = ?",
                (batch,)
            ) as cursor:
                row = await cursor.fetchone()
                video_count = row['count']
            
            # Add checkmark if selected
            is_selected = batch in user_selections
            prefix = "âœ… " if is_selected else ""
            
            kb.append([InlineKeyboardButton(
                f"{prefix}ğŸ“‚ {batch} ({video_count} videos)",
                callback_data=f"{action_prefix}:{batch}"
            )])
        
        if allow_multiple and user_selections:
            kb.append([InlineKeyboardButton(
                f"âœ… Confirm ({len(user_selections)} selected)", 
                callback_data=f"{action_prefix}:confirm"
            )])
        
        kb.append([InlineKeyboardButton("âŒ Cancel", callback_data="admin_panel:batch_mgmt")])
        return kb
    finally:
        await release_db(db)   

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›ï¸ ADMIN PANEL UI BUILDERS - PART 2 (NEW ENHANCED FEATURES)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def build_bulk_users_menu():
    """Build bulk user management menu (NEW)"""
    kb = [
        [InlineKeyboardButton("ğŸš« Bulk Block Users", callback_data="admin_bulk:block")],
        [InlineKeyboardButton("âœ… Bulk Unblock Users", callback_data="admin_bulk:unblock")],
        [InlineKeyboardButton("ğŸ’ Bulk Grant Downloads", callback_data="admin_bulk:grant")],
        [InlineKeyboardButton("ğŸ”„ Bulk Reset Usage", callback_data="admin_bulk:reset")],
        [InlineKeyboardButton("ğŸ“Š View User Groups", callback_data="admin_bulk:groups")],
        [InlineKeyboardButton("ğŸ”™ Back to Enhanced Features", callback_data="admin_panel:enhanced_features")]
    ]
    return kb


async def build_user_groups_menu():
    """Build user groups selection menu (NEW)"""
    kb = [
        [InlineKeyboardButton("ğŸ‘¥ All Users", callback_data="admin_bulk_target:all")],
        [InlineKeyboardButton("âœ… Active Today", callback_data="admin_bulk_target:active")],
        [InlineKeyboardButton("ğŸ’¤ Inactive (7+ days)", callback_data="admin_bulk_target:inactive")],
        [InlineKeyboardButton("ğŸš« Blocked Users", callback_data="admin_bulk_target:blocked")],
        [InlineKeyboardButton("ğŸ”¥ Heavy Users (50+ downloads)", callback_data="admin_bulk_target:heavy_users")],
        [InlineKeyboardButton("ğŸ†• New Users (Last 7 days)", callback_data="admin_bulk_target:new_users")],
        [InlineKeyboardButton("ğŸ”™ Back to Bulk Management", callback_data="admin_enhanced:bulk_users")]
    ]
    return kb


async def build_scheduled_broadcasts_menu():
    """Build scheduled broadcasts menu (NEW)"""
    # Get pending broadcasts count
    pending = await list_scheduled_broadcasts(status='pending')
    pending_count = len(pending)
    
    kb = [
        [InlineKeyboardButton(f"ğŸ“‹ View Pending ({pending_count})", callback_data="admin_scheduled:list_pending")],
        [InlineKeyboardButton("ğŸ“œ View Sent History", callback_data="admin_scheduled:list_sent")],
        [InlineKeyboardButton("â• Schedule New Broadcast", callback_data="admin_scheduled:new")],
        [InlineKeyboardButton("âŒ Cancel Scheduled", callback_data="admin_scheduled:cancel_menu")],
        [InlineKeyboardButton("ğŸ”™ Back to Enhanced Features", callback_data="admin_panel:enhanced_features")]
    ]
    return kb


async def build_batch_stats_selection():
    """Build batch selection for statistics (NEW)"""
    db = await get_db()
    try:
        kb = []
        
        # Get all batches with video counts
        async with db.execute(
            "SELECT DISTINCT batch FROM videos ORDER BY batch"
        ) as cursor:
            batches = []
            async for row in cursor:
                batches.append(row['batch'])
        
        # Show first 20 batches
        for batch in batches[:20]:
            async with db.execute(
                "SELECT COUNT(*) as count FROM videos WHERE batch = ?",
                (batch,)
            ) as cursor:
                video_count = (await cursor.fetchone())['count']
            
            kb.append([InlineKeyboardButton(
                f"ğŸ“‚ {batch} ({video_count} videos)",
                callback_data=f"admin_batch_stats:{batch}"
            )])
        
        kb.append([InlineKeyboardButton("ğŸ“Š View All Batches Summary", callback_data="admin_batch_stats:summary")])
        kb.append([InlineKeyboardButton("ğŸ”™ Back to Enhanced Features", callback_data="admin_panel:enhanced_features")])
        
        return kb
    finally:
        await release_db(db)


async def build_export_list_menu():
    """Build menu showing saved exports (NEW)"""
    exports = await list_category_exports()
    
    kb = []
    
    for export in exports[:10]:
        export_name = export['export_name']
        categories_count = export['categories_count']
        batches_count = export['batches_count']
        
        kb.append([InlineKeyboardButton(
            f"ğŸ“¦ {export_name} ({categories_count} cats, {batches_count} batches)",
            callback_data=f"admin_export_view:{export_name}"
        )])
    
    kb.append([InlineKeyboardButton("ğŸ”™ Back to Enhanced Features", callback_data="admin_panel:enhanced_features")])
    
    return kb


async def build_import_mode_menu():
    """Build import mode selection menu (NEW)"""
    kb = [
        [InlineKeyboardButton("ğŸ”€ Merge (Keep existing)", callback_data="admin_import_mode:merge")],
        [InlineKeyboardButton("ğŸ”„ Replace (Delete all first)", callback_data="admin_import_mode:replace")],
        [InlineKeyboardButton("â­ï¸ Skip Existing", callback_data="admin_import_mode:skip_existing")],
        [InlineKeyboardButton("âŒ Cancel", callback_data="admin_panel:enhanced_features")]
    ]
    return kb   

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ—‘ï¸ DELETE OPERATIONS HELPER FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def delete_batches(batch_list, admin_id, context):
    """Delete multiple batches"""
    db = await get_db()
    try:
        deleted_videos = 0
        
        for batch_name in batch_list:
            # Count videos
            async with db.execute(
                "SELECT COUNT(*) as count FROM videos WHERE batch = ?",
                (batch_name,)
            ) as cursor:
                row = await cursor.fetchone()
                deleted_videos += row['count']
            
            # Delete videos
            await db.execute("DELETE FROM videos WHERE batch = ?", (batch_name,))
            
            # Delete from category_batches
            await db.execute("DELETE FROM category_batches WHERE batch_name = ?", (batch_name,))
            
            # Delete subscriptions
            await db.execute("DELETE FROM subscriptions WHERE batch_name = ?", (batch_name,))
            
            # Delete batch metadata
            await db.execute("DELETE FROM batch_metadata WHERE batch_name = ?", (batch_name,))
        
        # Log deletion
        import json
        await db.execute(
            "INSERT INTO deletion_log (deletion_type, deleted_items, deleted_by, deleted_at) VALUES (?, ?, ?, ?)",
            ('batches', json.dumps(batch_list), admin_id, now_ist().isoformat())
        )
        
        await db.commit()
        
        await track_event("batches_deleted", admin_id, {"batches": batch_list, "videos": deleted_videos})
        
        # Send log to channel
        log_msg = format_message_header("BATCHES DELETED", "ğŸ—‘ï¸")
        log_msg += f"\nğŸ“‚ <b>Batches:</b> {len(batch_list)}\n"
        log_msg += f"ğŸ¬ <b>Videos:</b> {deleted_videos}\n"
        log_msg += f"ğŸ‘¤ <b>By Admin ID:</b> {admin_id}\n"
        log_msg += f"â° <b>Time:</b> {now_ist().strftime('%d/%m/%Y %I:%M %p')}"
        log_msg += format_message_footer()
        
        try:
            await context.bot.send_message(LOG_CHANNEL_ID, log_msg, parse_mode="HTML")
        except:
            pass
        
        return True
    finally:
        await release_db(db)  

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š ADMIN STATISTICS FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def admin_stats(update, context):
    """Comprehensive system statistics"""
    if update.effective_user.id not in [ADMIN_ID] + list(SUB_ADMINS):
        return
    
    db = await get_db()
    try:
        # Get user stats
        async with db.execute("SELECT COUNT(*) as count FROM users") as cursor:
            total_users = (await cursor.fetchone())['count']
        
        today = now_ist().date().isoformat()
        
        async with db.execute(
            "SELECT COUNT(*) as count FROM users WHERE usage_today > 0"
        ) as cursor:
            active_today = (await cursor.fetchone())['count']
        
        async with db.execute(
            "SELECT COUNT(*) as count FROM users WHERE joined_at LIKE ?",
            (f"{today}%",)
        ) as cursor:
            new_today = (await cursor.fetchone())['count']
        
        async with db.execute(
            "SELECT SUM(usage_today) as total FROM users"
        ) as cursor:
            downloads_today = (await cursor.fetchone())['total'] or 0
        
        async with db.execute(
            "SELECT COUNT(*) as count FROM users WHERE blocked = 1"
        ) as cursor:
            blocked_users = (await cursor.fetchone())['count']
        
        # Video stats
        async with db.execute("SELECT COUNT(*) as count FROM videos") as cursor:
            total_videos = (await cursor.fetchone())['count']
        
        async with db.execute("SELECT COUNT(DISTINCT batch) as count FROM videos") as cursor:
            total_batches = (await cursor.fetchone())['count']
        
        # Category stats
        async with db.execute("SELECT COUNT(*) as count FROM categories") as cursor:
            total_categories = (await cursor.fetchone())['count']
        
        # Subscription stats
        async with db.execute("SELECT COUNT(*) as count FROM subscriptions") as cursor:
            total_subscriptions = (await cursor.fetchone())['count']
        
        # Most active user
        async with db.execute(
            "SELECT username, total_downloads FROM users ORDER BY total_downloads DESC LIMIT 1"
        ) as cursor:
            most_active = await cursor.fetchone()
            most_active_name = most_active['username'] if most_active else "N/A"
            most_active_count = most_active['total_downloads'] if most_active else 0
        
        # Settings
        settings = await get_bot_settings()
        protect_status = "ğŸ”’ ON" if settings.get('protect_content') else "ğŸ”“ OFF"
        auto_delete_status = "âœ… ON" if settings.get('auto_delete') else "âŒ OFF"
        
        # Database size
        import os
        db_size = os.path.getsize(DB_PATH) if os.path.exists(DB_PATH) else 0
        db_size_mb = db_size / (1024 * 1024)
        
        stats_text = format_message_header("SYSTEM STATISTICS", "ğŸ“Š")
        stats_text += "\n<b>ğŸ“ˆ GROWTH METRICS</b>\n"
        stats_text += f"ğŸ‘¥ Total Users: <code>{total_users}</code>\n"
        stats_text += f"ğŸ†• New Today: <code>{new_today}</code>\n"
        
        if total_users:
            stats_text += f"âœ… Active Today: <code>{active_today}</code> ({active_today/total_users*100:.1f}%)\n"
        else:
            stats_text += f"âœ… Active Today: <code>{active_today}</code> (0.0%)\n"
        
        stats_text += f"ğŸš« Blocked: <code>{blocked_users}</code>\n\n"
        stats_text += "<b>ğŸ¬ CONTENT METRICS</b>\n"
        stats_text += f"ğŸ¥ Total Videos: <code>{total_videos}</code>\n"
        stats_text += f"ğŸ“‚ Total Batches: <code>{total_batches}</code>\n"
        stats_text += f"ğŸ“š Total Categories: <code>{total_categories}</code>\n\n"
        stats_text += "<b>ğŸ’¾ USAGE METRICS</b>\n"
        stats_text += f"ğŸ“¥ Downloads Today: <code>{downloads_today}</code>\n"
        stats_text += f"ğŸ† Top User: <code>{most_active_name}</code> ({most_active_count} total)\n"
        stats_text += f"ğŸ“¬ Total Subscriptions: <code>{total_subscriptions}</code>\n\n"
        stats_text += "<b>âš¡ SYSTEM INFO</b>\n"
        stats_text += f"ğŸ’½ Database Size: <code>{db_size_mb:.2f} MB</code>\n"
        stats_text += f"ğŸ”’ Protect Content: {protect_status}\n"
        stats_text += f"ğŸ—‘ï¸ Auto Delete: {auto_delete_status}\n"
        stats_text += f"ğŸ•’ Server Time: <code>{now_ist().strftime('%I:%M %p IST')}</code>\n"
        stats_text += format_message_footer()
        
        kb = [
            [InlineKeyboardButton("ğŸ“„ User Report", callback_data="admin_stats:user_txt"),
             InlineKeyboardButton("ğŸ¬ Video Report", callback_data="admin_stats:video_txt")],
            [InlineKeyboardButton("ğŸ”„ Refresh", callback_data="admin_stats:system")],
            [InlineKeyboardButton("ğŸ”™ Back to Panel", callback_data="admin_panel:main")]
        ]
        
        if hasattr(update, 'callback_query') and update.callback_query:
            await edit_with_retry(update.callback_query, stats_text, parse_mode="HTML", reply_markup=InlineKeyboardMarkup(kb))
        else:
            await update.message.reply_text(stats_text, parse_mode="HTML", reply_markup=InlineKeyboardMarkup(kb))
    
    finally:
        await release_db(db)


async def admin_list_batches(query, context):
    """List all batches"""
    db = await get_db()
    try:
        batches_dict = {}
        async with db.execute(
            "SELECT batch, COUNT(*) as count FROM videos GROUP BY batch ORDER BY batch"
        ) as cursor:
            async for row in cursor:
                batches_dict[row['batch']] = row['count']
        
        if not batches_dict:
            await query.message.reply_text(
                format_error_message("No batches found!"),
                parse_mode="HTML"
            )
            return
        
        batch_text = format_message_header("ALL BATCHES", "ğŸ“‚")
        batch_text += f"\n<b>Total:</b> {len(batches_dict)}\n\n"
        
        for batch, count in list(batches_dict.items())[:30]:
            batch_text += f"â€¢ {batch} ({count} videos)\n"
        
        if len(batches_dict) > 30:
            batch_text += f"\n...and {len(batches_dict) - 30} more\n"
        
        batch_text += format_message_footer()
        
        await query.message.reply_text(batch_text, parse_mode="HTML")
    finally:
        await release_db(db)


async def admin_batch_stats(query, context):
    """Show batch statistics"""
    db = await get_db()
    try:
        batch_stats = []
        async with db.execute(
            """SELECT v.batch, COUNT(v.msg_id) as video_count, 
               COALESCE(b.subscribers, 0) as subscribers
               FROM videos v
               LEFT JOIN batch_metadata b ON v.batch = b.batch_name
               GROUP BY v.batch
               ORDER BY video_count DESC
               LIMIT 10"""
        ) as cursor:
            async for row in cursor:
                batch_stats.append(dict(row))
        
        async with db.execute("SELECT COUNT(DISTINCT batch) as count FROM videos") as cursor:
            total_batches = (await cursor.fetchone())['count']
        
        async with db.execute("SELECT COUNT(*) as count FROM videos") as cursor:
            total_videos = (await cursor.fetchone())['count']
        
        stats_text = format_message_header("BATCH STATISTICS", "ğŸ“Š")
        stats_text += f"\n<b>Total Batches:</b> {total_batches}\n"
        stats_text += f"<b>Total Videos:</b> {total_videos}\n\n"
        stats_text += "<b>TOP 10 BATCHES BY VIDEO COUNT:</b>\n\n"
        
        for i, batch in enumerate(batch_stats, 1):
            stats_text += f"{i}. <b>{batch['batch']}</b>\n"
            stats_text += f"   â””â”€ {batch['video_count']} videos | {batch['subscribers']} subscribers\n"
        
        stats_text += format_message_footer()
        
        await query.message.reply_text(stats_text, parse_mode="HTML")
    finally:
        await release_db(db)


async def admin_listcategories(update, context):
    """List all categories with their batches (FIXED - Dual mode support)"""
    # Support both query and update
    if hasattr(update, 'callback_query') and update.callback_query:
        query = update.callback_query
        user_id = query.from_user.id
        send_method = query.message.reply_text
    else:
        user_id = update.effective_user.id
        send_method = update.message.reply_text
    
    if user_id not in [ADMIN_ID] + list(SUB_ADMINS):
        return
    
    db = await get_db()
    try:
        async with db.execute(
            "SELECT category_name, emoji FROM categories ORDER BY category_name"
        ) as cursor:
            categories = await cursor.fetchall()
        
        if not categories:
            no_cat_msg = format_message_header("NO CATEGORIES", "ğŸ“š")
            no_cat_msg += "No categories created yet.\n\n"
            no_cat_msg += "Use /addcategory to create one!"
            no_cat_msg += format_message_footer()
            
            return await send_method(no_cat_msg, parse_mode="HTML")
        
        report_text = format_message_header("CATEGORIES LIST", "ğŸ“š")
        report_text += "\n"
        
        for cat in categories:
            cat_name = cat['category_name']
            cat_emoji = cat['emoji']
            
            async with db.execute(
                "SELECT batch_name FROM category_batches WHERE category_name = ?",
                (cat_name,)
            ) as cursor:
                batches = await cursor.fetchall()
            
            report_text += f"{cat_emoji} <b>{cat_name}</b> ({len(batches)} batches)\n"
            
            if batches:
                for batch_row in batches:
                    batch_name = batch_row['batch_name']
                    async with db.execute(
                        "SELECT COUNT(*) as count FROM videos WHERE batch = ?",
                        (batch_name,)
                    ) as vid_cursor:
                        vid_count = (await vid_cursor.fetchone())['count']
                    
                    report_text += f"   â””â”€ {batch_name} ({vid_count} videos)\n"
            else:
                report_text += "   â””â”€ (empty)\n"
            
            report_text += "\n"
        
        report_text += format_message_footer()
        
        await send_method(report_text, parse_mode="HTML")
    finally:
        await release_db(db)


async def admin_uncategorized(update, context):
    """List all batches that don't belong to any category (FIXED - Dual mode support)"""
    # Support both query and update
    if hasattr(update, 'callback_query') and update.callback_query:
        query = update.callback_query
        user_id = query.from_user.id
        send_method = query.message.reply_text
    else:
        user_id = update.effective_user.id
        send_method = update.message.reply_text
    
    if user_id not in [ADMIN_ID] + list(SUB_ADMINS):
        return
    
    uncategorized = await get_uncategorized_batches()
    
    db = await get_db()
    try:
        if not uncategorized:
            success_msg = format_message_header("ALL BATCHES CATEGORIZED", "âœ…")
            success_msg += "All batches are assigned to categories!"
            success_msg += format_message_footer()
            
            return await send_method(success_msg, parse_mode="HTML")
        
        report_text = format_message_header("UNCATEGORIZED BATCHES", "ğŸ“‚")
        report_text += f"\n<b>Total:</b> {len(uncategorized)}\n\n"
        
        for batch in sorted(uncategorized):
            async with db.execute(
                "SELECT COUNT(*) as count FROM videos WHERE batch = ?",
                (batch,)
            ) as cursor:
                video_count = (await cursor.fetchone())['count']
            
            report_text += f"â€¢ {batch} ({video_count} videos)\n"
        
        report_text += "\n" + format_message_footer()
        report_text += "\nğŸ’¡ Use /assignbatch to categorize them!"
        
        await send_method(report_text, parse_mode="HTML")
    finally:
        await release_db(db)


async def admin_usertxt(update, context):
    """Generate comprehensive user analytics report"""
    if update.effective_user.id not in [ADMIN_ID] + list(SUB_ADMINS):
        return
    
    db = await get_db()
    try:
        async with db.execute(
            "SELECT * FROM users ORDER BY total_downloads DESC"
        ) as cursor:
            users = await cursor.fetchall()
        
        report_path = os.path.join(DATA_DIR, "user_analytics_report.txt")
        
        with open(report_path, "w", encoding="utf-8") as f:
            f.write("=" * 60 + "\n")
            f.write("ğŸ“Š USER ANALYTICS REPORT\n")
            f.write(f"Generated: {now_ist().strftime('%d/%m/%Y %I:%M %p IST')}\n")
            f.write("=" * 60 + "\n\n")
            
            total_users = len(users)
            active_users = sum(1 for u in users if u['usage_today'] > 0)
            blocked_users = sum(1 for u in users if u['blocked'])
            
            f.write("ğŸ“ˆ SUMMARY\n")
            f.write("-" * 60 + "\n")
            f.write(f"Total Users:          {total_users}\n")
            
            if total_users:
                f.write(f"Active Today:         {active_users} ({active_users/total_users*100:.1f}%)\n")
            else:
                f.write("Active Today:         0 (0.0%)\n")
            
            f.write(f"Blocked Users:        {blocked_users}\n")
            f.write("\n" + "=" * 60 + "\n\n")
            
            f.write("ğŸ† TOP 20 USERS BY DOWNLOADS\n")
            f.write("-" * 60 + "\n")
            for i, user in enumerate(users[:20], 1):
                f.write(f"{i:2d}. {user['username'][:25]:<25} | ID: {user['user_id']}\n")
                f.write(f"    Total: {user['total_downloads']:4d} | Today: {user['usage_today']:2d}\n")
                f.write(f"    Status: {'ğŸš« BLOCKED' if user['blocked'] else 'âœ… Active'}\n")
                f.write("\n")
            
            f.write("=" * 60 + "\n")
            f.write("END OF REPORT\n")
            f.write("=" * 60 + "\n")
        
        with open(report_path, "rb") as f:
            caption_text = format_message_header("USER ANALYTICS REPORT", "ğŸ“„")
            caption_text += f"ğŸ‘¥ <b>Users Analyzed:</b> {total_users}\n"
            caption_text += f"â° <b>Generated:</b> {now_ist().strftime('%d/%m/%Y %I:%M %p')}"
            caption_text += format_message_footer()
            
            if hasattr(update, 'callback_query') and update.callback_query:
                await update.callback_query.message.reply_document(
                    f,
                    caption=caption_text,
                    parse_mode="HTML"
                )
            else:
                await update.message.reply_document(
                    f,
                    caption=caption_text,
                    parse_mode="HTML"
                )
    finally:
        await release_db(db)


async def admin_videotxt(update, context):
    """Generate comprehensive video analytics report"""
    if update.effective_user.id not in [ADMIN_ID] + list(SUB_ADMINS):
        return
    
    db = await get_db()
    try:
        async with db.execute(
            "SELECT batch, COUNT(*) as count FROM videos GROUP BY batch ORDER BY count DESC"
        ) as cursor:
            batch_stats = await cursor.fetchall()
        
        async with db.execute("SELECT COUNT(*) as count FROM videos") as cursor:
            total_videos = (await cursor.fetchone())['count']
        
        report_path = os.path.join(DATA_DIR, "video_analytics_report.txt")
        
        with open(report_path, "w", encoding="utf-8") as f:
            f.write("=" * 60 + "\n")
            f.write("ğŸ¬ VIDEO ANALYTICS REPORT\n")
            f.write(f"Generated: {now_ist().strftime('%d/%m/%Y %I:%M %p IST')}\n")
            f.write("=" * 60 + "\n\n")
            
            f.write("ğŸ“ˆ SUMMARY\n")
            f.write("-" * 60 + "\n")
            f.write(f"Total Videos:    {total_videos}\n")
            f.write(f"Total Batches:   {len(batch_stats)}\n")
            f.write("\n" + "=" * 60 + "\n\n")
            
            f.write("ğŸ“‚ BATCH ANALYSIS\n")
            f.write("-" * 60 + "\n\n")
            
            for batch in batch_stats:
                f.write(f"ğŸ“‚ {batch['batch']}\n")
                f.write(f"â”œâ”€ Videos: {batch['count']}\n\n")
            
            f.write("=" * 60 + "\n")
            f.write("END OF REPORT\n")
            f.write("=" * 60 + "\n")
        
        with open(report_path, "rb") as f:
            caption_text = format_message_header("VIDEO ANALYTICS REPORT", "ğŸ¬")
            caption_text += f"ğŸ¥ <b>Videos:</b> {total_videos} | ğŸ“‚ <b>Batches:</b> {len(batch_stats)}\n"
            caption_text += f"â° <b>Generated:</b> {now_ist().strftime('%d/%m/%Y %I:%M %p')}"
            caption_text += format_message_footer()
            
            if hasattr(update, 'callback_query') and update.callback_query:
                await update.callback_query.message.reply_document(
                    f,
                    caption=caption_text,
                    parse_mode="HTML"
                )
            else:
                await update.message.reply_document(
                    f,
                    caption=caption_text,
                    parse_mode="HTML"
                )
    finally:
        await release_db(db) 

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›ï¸ ADMIN COMMANDS - SYSTEM MANAGEMENT (PART 1)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def cmd_adminpanel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Main admin panel command"""
    if not is_admin(update.effective_user.id):
        return await update.message.reply_text(
            format_error_message("Unauthorized! Admin only."),
            parse_mode="HTML"
        )
    
    panel_text = format_message_header("ADMIN CONTROL PANEL", "ğŸ›ï¸")
    panel_text += "Welcome to the Admin Control Panel.\n\n"
    panel_text += "Select an option below to manage the bot:"
    panel_text += format_message_footer()
    
    await update.message.reply_text(
        panel_text,
        reply_markup=InlineKeyboardMarkup(build_admin_panel_main()),
        parse_mode="HTML"
    )


async def cmd_settime(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Set auto delete time"""
    if not is_admin(update.effective_user.id) or not context.args:
        return
    
    try:
        seconds = int(context.args[0])
        if seconds < 10 or seconds > 600:
            raise ValueError("Time must be between 10 and 600 seconds")
        
        await update_bot_setting('auto_delete_seconds', seconds)
        
        success_msg = format_success_message(
            f"Auto delete time set to <b>{seconds} seconds</b>."
        )
        await update.message.reply_text(success_msg, parse_mode="HTML")
        
    except ValueError as e:
        error_msg = format_error_message(
            f"Invalid time value!\n\nUsage: /settime <seconds>\nRange: 10-600 seconds"
        )
        await update.message.reply_text(error_msg, parse_mode="HTML")


async def cmd_setemoji(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Set emoji for different elements"""
    if not is_admin(update.effective_user.id) or len(context.args) < 3:
        usage_msg = format_message_header("SET EMOJI", "ğŸ˜€")
        usage_msg += "Usage:\n"
        usage_msg += "<code>/setemoji file_type &lt;type&gt; &lt;emoji&gt;</code>\n"
        usage_msg += "<code>/setemoji ui &lt;element&gt; &lt;emoji&gt;</code>\n"
        usage_msg += "<code>/setemoji category &lt;name&gt; &lt;emoji&gt;</code>\n\n"
        usage_msg += "<b>Examples:</b>\n"
        usage_msg += "<code>/setemoji file_type video ğŸ¬</code>\n"
        usage_msg += "<code>/setemoji ui home ğŸ¡</code>\n"
        usage_msg += "<code>/setemoji category Quant ğŸ”¢</code>"
        usage_msg += format_message_footer()
        
        return await update.message.reply_text(usage_msg, parse_mode="HTML")
    
    setting_type = context.args[0]
    setting_key = context.args[1]
    emoji = context.args[2]
    
    db = await get_db()
    try:
        if setting_type == "category":
            # Update category emoji
            await db.execute(
                "UPDATE categories SET emoji = ? WHERE category_name = ?",
                (emoji, setting_key)
            )
            await db.commit()
            
            success_msg = format_success_message(
                f"Emoji for category '<b>{setting_key}</b>' set to {emoji}"
            )
        else:
            # Update emoji settings
            await db.execute(
                "INSERT OR REPLACE INTO emoji_settings (setting_type, setting_key, emoji) VALUES (?, ?, ?)",
                (setting_type, setting_key, emoji)
            )
            await db.commit()
            
            success_msg = format_success_message(
                f"Emoji for {setting_type} '<b>{setting_key}</b>' set to {emoji}"
            )
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
    finally:
        await release_db(db)


async def cmd_setfooter(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Set footer name for caption design"""
    if not is_admin(update.effective_user.id) or not context.args:
        info_text = format_message_header("SET FOOTER NAME", "âœï¸")
        info_text += "Usage: <code>/setfooter &lt;name&gt;</code>\n\n"
        info_text += "<b>Examples:</b>\n"
        info_text += "â€¢ <code>/setfooter Team Bot</code>\n"
        info_text += "â€¢ <code>/setfooter @MyChannel</code>"
        info_text += format_message_footer()
        
        return await update.message.reply_text(info_text, parse_mode="HTML")
    
    footer_name = " ".join(context.args)
    await update_bot_setting('footer_name', footer_name)
    
    success_msg = format_success_message(f"Footer name set to: <b>{footer_name}</b>")
    await update.message.reply_text(success_msg, parse_mode="HTML")


async def cmd_setanimation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Set animation emoji and duration"""
    if not is_admin(update.effective_user.id) or len(context.args) < 3:
        info_text = format_message_header("SET ANIMATION", "ğŸ¬")
        info_text += "Usage: <code>/setanimation &lt;type&gt; &lt;emoji&gt; &lt;seconds&gt;</code>\n\n"
        info_text += "<b>Types:</b> loading, processing, search, stats, start, contact\n\n"
        info_text += "<b>Examples:</b>\n"
        info_text += "â€¢ <code>/setanimation loading ğŸ¦‡ 2.0</code>\n"
        info_text += "â€¢ <code>/setanimation search ğŸ” 1.5</code>"
        info_text += format_message_footer()
        
        return await update.message.reply_text(info_text, parse_mode="HTML")
    
    anim_type = context.args[0]
    emoji = context.args[1]
    duration = float(context.args[2])
    
    if anim_type not in ['loading', 'processing', 'search', 'stats', 'start', 'contact']:
        return await update.message.reply_text(
            format_error_message("Invalid animation type! Use: loading, processing, search, stats, start, or contact"),
            parse_mode="HTML"
        )
    
    await update_animation_setting(anim_type, emoji=emoji, duration=duration)
    
    success_msg = format_success_message(
        f"Animation updated!\n\n"
        f"<b>Type:</b> {anim_type}\n"
        f"<b>Emoji:</b> {emoji}\n"
        f"<b>Duration:</b> {duration}s"
    )
    await update.message.reply_text(success_msg, parse_mode="HTML")


async def cmd_toggleanimation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Toggle specific animation on/off"""
    if not is_admin(update.effective_user.id):
        return
    
    if not context.args:
        info_text = format_message_header("TOGGLE ANIMATION", "ğŸ”„")
        info_text += "Usage: <code>/toggleanimation &lt;type&gt;</code>\n\n"
        info_text += "<b>Types:</b> loading, processing, search, stats, start, contact\n\n"
        info_text += "<b>Example:</b>\n<code>/toggleanimation loading</code>"
        info_text += format_message_footer()
        
        return await update.message.reply_text(info_text, parse_mode="HTML")
    
    anim_type = context.args[0]
    
    if anim_type not in ['loading', 'processing', 'search', 'stats', 'start', 'contact']:
        return await update.message.reply_text(
            format_error_message("Invalid animation type!"),
            parse_mode="HTML"
        )
    
    settings = await get_animation_settings()
    anim = settings.get(anim_type, {})
    current = anim.get('enabled', True)
    new_value = not current
    
    await update_animation_setting(anim_type, enabled=new_value)
    
    status = "âœ… ENABLED" if new_value else "âŒ DISABLED"
    success_msg = format_success_message(
        f"{anim_type.title()} animation: {status}"
    )
    await update.message.reply_text(success_msg, parse_mode="HTML")


async def cmd_animationstatus(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show current animation settings"""
    if not is_admin(update.effective_user.id):
        return
    
    settings = await get_animation_settings()
    
    global_status = "âœ… ENABLED" if settings.get('global_enabled') else "âŒ DISABLED"
    
    status_text = format_message_header("ANIMATION STATUS", "ğŸ¬")
    status_text += f"\n<b>Global:</b> {global_status}\n\n"
    status_text += "<b>Individual Animations:</b>\n"
    
    for anim_type in ['loading', 'processing', 'search', 'stats', 'start', 'contact']:
        anim = settings.get(anim_type, {})
        emoji = anim.get('emoji', 'ğŸš€')
        duration = anim.get('duration', 1.5)
        enabled = anim.get('enabled', True)
        status = "âœ… ON" if enabled else "âŒ OFF"
        
        status_text += f"â”œâ”€ {emoji} {anim_type.title()}: {status} ({duration}s)\n"
    
    status_text += format_message_footer()
    
    await update.message.reply_text(status_text, parse_mode="HTML")


async def admin_userinfo(update, context):
    """Enhanced user information with more analytics"""
    if not is_admin(update.effective_user.id) or not context.args:
        return
    
    uid = int(context.args[0])
    
    db = await get_db()
    try:
        async with db.execute("SELECT * FROM users WHERE user_id = ?", (uid,)) as cursor:
            user = await cursor.fetchone()
        
        if not user:
            return await update.message.reply_text(
                format_error_message("User not found!"),
                parse_mode="HTML"
            )
        
        user = dict(user)
        
        # Get subscriptions
        async with db.execute(
            "SELECT batch_name FROM subscriptions WHERE user_id = ?",
            (uid,)
        ) as cursor:
            subs = []
            async for row in cursor:
                subs.append(row['batch_name'])
        
        # Get recent history
        async with db.execute(
            "SELECT v.caption, h.timestamp FROM user_history h JOIN videos v ON h.video_id = v.msg_id WHERE h.user_id = ? ORDER BY h.timestamp DESC LIMIT 10",
            (uid,)
        ) as cursor:
            history = []
            async for row in cursor:
                history.append(f"[{row['timestamp'][:16]}] {row['caption'][:25]}")
        
        joined_date = parse_iso(user.get("joined_at"))
        days_member = (now_ist() - joined_date).days if joined_date else 0
        
        total_dl = user.get("total_downloads", 0)
        searches = user.get("search_count", 0)
        activity_score = (total_dl * 2 + searches) / (days_member + 1)
        
        hist_str = "\n".join(f"  â€¢ {h}" for h in history[:10]) or "  No recent activity"
        subs_str = "\n".join(f"  â€¢ {s}" for s in subs[:10]) or "  None"
        
        info_txt = format_message_header("DETAILED USER INFORMATION", "ğŸ‘¤")
        info_txt += "\n<b>BASIC INFO</b>\n"
        info_txt += f"ğŸ†” <b>ID:</b> <code>{uid}</code>\n"
        info_txt += f"ğŸ· <b>Name:</b> {user.get('username', 'Unknown')}\n"
        info_txt += f"ğŸ“… <b>Joined:</b> {user.get('joined_at', 'N/A')[:10]}\n"
        info_txt += f"â± <b>Member for:</b> {days_member} days\n"
        info_txt += f"ğŸ•’ <b>Last Active:</b> {user.get('last_active', 'N/A')[:16]}\n\n"
        info_txt += "<b>USAGE STATISTICS</b>\n"
        info_txt += f"ğŸ“Š <b>Today:</b> {user.get('usage_today', 0)} / {user.get('daily_limit', 5) + user.get('extra_granted', 0)}\n"
        info_txt += f"ğŸ“¦ <b>Total Downloads:</b> {total_dl}\n"
        info_txt += f"ğŸ” <b>Total Searches:</b> {searches}\n"
        info_txt += f"ğŸ’ <b>Extra Granted:</b> {user.get('extra_granted', 0)}\n"
        info_txt += f"ğŸ“ˆ <b>Activity Score:</b> {activity_score:.2f}/day\n"
        info_txt += f"â­ <b>Favorite Batch:</b> {user.get('favorite_batch', 'None')}\n\n"
        info_txt += "<b>ACCOUNT STATUS</b>\n"
        info_txt += f"ğŸš« <b>Blocked:</b> {'Yes' if user.get('blocked') else 'No'}\n"
        info_txt += f"ğŸ”• <b>Silent Mode:</b> {user.get('silent_mode', 'None')}\n"
        info_txt += f"ğŸ‘¤ <b>Sub-Admin:</b> {'Yes' if user.get('is_sub_admin') else 'No'}\n"
        info_txt += f"ğŸ <b>Bonus Claimed:</b> {user.get('bonus_claimed_date', 'Never')}\n\n"
        info_txt += f"<b>SUBSCRIPTIONS ({len(subs)})</b>\n"
        info_txt += f"{subs_str}\n\n"
        info_txt += "<b>RECENT DOWNLOAD HISTORY</b>\n"
        info_txt += f"{hist_str}\n"
        info_txt += format_message_footer()
        
        kb = [
            [InlineKeyboardButton("ğŸš« Block", callback_data=f"admin_block:{uid}"),
             InlineKeyboardButton("âœ… Unblock", callback_data=f"admin_unblock:{uid}")],
            [InlineKeyboardButton("ğŸ’ Grant +5", callback_data=f"admin_quickgrant:{uid}:5"),
             InlineKeyboardButton("ğŸ”„ Reset", callback_data=f"admin_reset:{uid}")]
        ]
        
        await update.message.reply_text(info_txt, parse_mode="HTML", reply_markup=InlineKeyboardMarkup(kb))
    finally:
        await release_db(db)    

        
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“š CATEGORY MANAGEMENT COMMANDS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def admin_addcategory(update, context):
    """Add new category - handle both command and interactive"""
    if not is_admin(update.effective_user.id):
        return
    
    # Check if command has args
    if context.args:
        category_name = " ".join(context.args)
    else:
        # Check if this is from interactive mode
        if update.effective_user.id in pending_operations:
            op = pending_operations[update.effective_user.id]
            if op.get('action') == 'add_category' and op.get('step') == 'waiting_name':
                category_name = update.message.text.strip()
                pending_operations.pop(update.effective_user.id)
            else:
                return
        else:
            # Start interactive mode
            return
    
    db = await get_db()
    try:
        # Check if category exists
        async with db.execute(
            "SELECT category_name FROM categories WHERE category_name = ?",
            (category_name,)
        ) as cursor:
            existing = await cursor.fetchone()
        
        if existing:
            return await update.message.reply_text(
                format_error_message(f"Category '{category_name}' already exists!"),
                parse_mode="HTML"
            )
        
        # Ask for confirmation
        kb = [
            [InlineKeyboardButton("âœ… YES, CREATE IT", callback_data=f"confirm_add_cat:{category_name}")],
            [InlineKeyboardButton("âŒ CANCEL", callback_data="admin_panel:category_mgmt")]
        ]
        
        confirm_text = format_message_header("CONFIRM CREATION", "â•")
        confirm_text += f"\nğŸ“š <b>Category Name:</b> {category_name}\n\n"
        confirm_text += "Create this category?"
        confirm_text += format_message_footer()
        
        await update.message.reply_text(
            confirm_text,
            reply_markup=InlineKeyboardMarkup(kb),
            parse_mode="HTML"
        )
    finally:
        await release_db(db)


async def admin_renamecategory(update, context):
    """Rename existing category - handle both command and interactive"""
    if not is_admin(update.effective_user.id):
        return
    
    # Check if this is from interactive mode
    if update.effective_user.id in pending_operations:
        op = pending_operations[update.effective_user.id]
        if op.get('action') == 'rename_category' and op.get('step') == 'waiting_new_name':
            old_name = op.get('old_name')
            new_name = update.message.text.strip()
            pending_operations.pop(update.effective_user.id)
            
            # Ask for confirmation
            kb = [
                [InlineKeyboardButton("âœ… YES, RENAME IT", callback_data=f"confirm_rename_cat:{old_name}:{new_name}")],
                [InlineKeyboardButton("âŒ CANCEL", callback_data="admin_panel:category_mgmt")]
            ]
            
            confirm_text = format_message_header("CONFIRM RENAME", "âœï¸")
            confirm_text += f"\nğŸ“ <b>From:</b> {old_name}\n"
            confirm_text += f"ğŸ“ <b>To:</b> {new_name}\n\n"
            confirm_text += "Rename this category?"
            confirm_text += format_message_footer()
            
            await update.message.reply_text(
                confirm_text,
                reply_markup=InlineKeyboardMarkup(kb),
                parse_mode="HTML"
            )
            return
    
    # Command mode
    if len(context.args) < 2:
        return await update.message.reply_text(
            format_error_message("Usage: /renamecategory <old_name> <new_name>"),
            parse_mode="HTML"
        )
    
    old_name = context.args[0]
    new_name = " ".join(context.args[1:])
    
    db = await get_db()
    try:
        async with db.execute(
            "SELECT category_name FROM categories WHERE category_name = ?",
            (old_name,)
        ) as cursor:
            existing = await cursor.fetchone()
        
        if not existing:
            return await update.message.reply_text(
                format_error_message(f"Category '{old_name}' not found!"),
                parse_mode="HTML"
            )
        
        async with db.execute(
            "SELECT category_name FROM categories WHERE category_name = ?",
            (new_name,)
        ) as cursor:
            duplicate = await cursor.fetchone()
        
        if duplicate:
            return await update.message.reply_text(
                format_error_message(f"Category '{new_name}' already exists!"),
                parse_mode="HTML"
            )
        
        # Update category name
        await db.execute(
            "UPDATE categories SET category_name = ? WHERE category_name = ?",
            (new_name, old_name)
        )
        
        await db.execute(
            "UPDATE category_batches SET category_name = ? WHERE category_name = ?",
            (new_name, old_name)
        )
        
        await db.commit()
        
        success_msg = format_message_header("CATEGORY RENAMED", "âœ…")
        success_msg += f"ğŸ“ <b>From:</b> {old_name}\n"
        success_msg += f"ğŸ“ <b>To:</b> {new_name}"
        success_msg += format_message_footer()
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
    finally:
        await release_db(db)


async def admin_deletecategory(update, context):
    """Delete category - handled via interactive mode"""
    if not is_admin(update.effective_user.id):
        return
    
    if not context.args:
        return await update.message.reply_text(
            format_error_message("Usage: /deletecategory <category_name>"),
            parse_mode="HTML"
        )
    
    category_name = " ".join(context.args)
    
    db = await get_db()
    try:
        async with db.execute(
            "SELECT category_name FROM categories WHERE category_name = ?",
            (category_name,)
        ) as cursor:
            existing = await cursor.fetchone()
        
        if not existing:
            return await update.message.reply_text(
                format_error_message(f"Category '{category_name}' not found!"),
                parse_mode="HTML"
            )
        
        async with db.execute(
            "SELECT COUNT(*) as count FROM category_batches WHERE category_name = ?",
            (category_name,)
        ) as cursor:
            batch_count = (await cursor.fetchone())['count']
        
        # Delete category
        await db.execute("DELETE FROM category_batches WHERE category_name = ?", (category_name,))
        await db.execute("DELETE FROM categories WHERE category_name = ?", (category_name,))
        await db.commit()
        
        success_msg = format_message_header("CATEGORY DELETED", "âœ…")
        success_msg += f"ğŸ—‘ï¸ <b>Name:</b> {category_name}\n"
        success_msg += f"ğŸ“‚ <b>Batches unlinked:</b> {batch_count}\n\n"
        success_msg += "ğŸ’¡ Batches are now uncategorized.\nUse /uncategorized to view them."
        success_msg += format_message_footer()
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
    finally:
        await release_db(db)


async def admin_assignbatch(update, context):
    """Assign batch to category"""
    if not is_admin(update.effective_user.id) or len(context.args) < 2:
        return await update.message.reply_text(
            format_error_message('Usage: /assignbatch <category> <batch_name>\nExample: /assignbatch Quant "PERFECTION 12"'),
            parse_mode="HTML"
        )
    
    category_name = context.args[0]
    batch_name = " ".join(context.args[1:]).strip('"')
    
    db = await get_db()
    try:
        # Check if category exists
        async with db.execute(
            "SELECT category_name FROM categories WHERE category_name = ?",
            (category_name,)
        ) as cursor:
            category = await cursor.fetchone()
        
        if not category:
            return await update.message.reply_text(
                format_error_message(f"Category '{category_name}' not found!\nUse /listcategories to see available categories."),
                parse_mode="HTML"
            )
        
        # Check if batch exists
        async with db.execute(
            "SELECT DISTINCT batch FROM videos WHERE batch = ?",
            (batch_name,)
        ) as cursor:
            batch = await cursor.fetchone()
        
        if not batch:
            return await update.message.reply_text(
                format_error_message(f"Batch '{batch_name}' not found in database!"),
                parse_mode="HTML"
            )
        
        # Check if already assigned
        async with db.execute(
            "SELECT category_name FROM category_batches WHERE batch_name = ?",
            (batch_name,)
        ) as cursor:
            existing = await cursor.fetchone()
        
        if existing:
            return await update.message.reply_text(
                format_error_message(f"Batch '{batch_name}' is already in category '{existing['category_name']}'!\nUse /unassignbatch first if you want to move it."),
                parse_mode="HTML"
            )
        
        # Assign batch
        await db.execute(
            "INSERT INTO category_batches (category_name, batch_name) VALUES (?, ?)",
            (category_name, batch_name)
        )
        await db.commit()
        
        success_msg = format_message_header("BATCH ASSIGNED", "âœ…")
        success_msg += f"ğŸ“š <b>Category:</b> {category_name}\n"
        success_msg += f"ğŸ“‚ <b>Batch:</b> {batch_name}"
        success_msg += format_message_footer()
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
    finally:
        await release_db(db)


async def admin_unassignbatch(update, context):
    """Remove batch from its category"""
    if not is_admin(update.effective_user.id) or not context.args:
        return await update.message.reply_text(
            format_error_message("Usage: /unassignbatch <batch_name>"),
            parse_mode="HTML"
        )
    
    batch_name = " ".join(context.args).strip('"')
    
    db = await get_db()
    try:
        # Check if batch is assigned
        async with db.execute(
            "SELECT category_name FROM category_batches WHERE batch_name = ?",
            (batch_name,)
        ) as cursor:
            existing = await cursor.fetchone()
        
        if not existing:
            return await update.message.reply_text(
                format_error_message(f"Batch '{batch_name}' is not assigned to any category!"),
                parse_mode="HTML"
            )
        
        cat_name = existing['category_name']
        
        # Unassign batch
        await db.execute(
            "DELETE FROM category_batches WHERE batch_name = ?",
            (batch_name,)
        )
        await db.commit()
        
        success_msg = format_message_header("BATCH UNASSIGNED", "âœ…")
        success_msg += f"ğŸ“‚ <b>Batch:</b> {batch_name}\n"
        success_msg += f"ğŸ—‘ï¸ <b>Removed from:</b> {cat_name}"
        success_msg += format_message_footer()
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
    finally:
        await release_db(db)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ‘¥ USER MANAGEMENT COMMANDS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def admin_grant(update, context):
    """Grant extra downloads to user"""
    if not is_admin(update.effective_user.id) or len(context.args) < 2:
        return
    
    uid = int(context.args[0])
    amt = int(context.args[1])
    
    db = await get_db()
    try:
        await db.execute(
            "UPDATE users SET extra_granted = extra_granted + ? WHERE user_id = ?",
            (amt, uid)
        )
        await db.commit()
        
        success_msg = format_message_header("GRANT SUCCESS", "ğŸ’")
        success_msg += f"Granted <b>+{amt}</b> downloads to user ID: <code>{uid}</code>"
        success_msg += format_message_footer()
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
        
        settings = await get_bot_settings()
        protect_content = settings.get('protect_content', False)
        
        user_msg = format_message_header("BONUS RECEIVED", "ğŸ’")
        user_msg += f"Admin granted you <b>+{amt}</b> extra downloads!"
        user_msg += format_message_footer()
        
        try:
            await context.bot.send_message(uid, user_msg, parse_mode="HTML", protect_content=protect_content)
        except:
            pass
    finally:
        await release_db(db)


async def admin_revoke(update, context):
    """Revoke extra downloads from user"""
    if not is_admin(update.effective_user.id) or len(context.args) < 2:
        return
    
    uid = int(context.args[0])
    amt = int(context.args[1])
    
    db = await get_db()
    try:
        await db.execute(
            "UPDATE users SET extra_granted = MAX(0, extra_granted - ?) WHERE user_id = ?",
            (amt, uid)
        )
        await db.commit()
        
        success_msg = format_message_header("REVOKE SUCCESS", "ğŸ“‰")
        success_msg += f"Revoked <b>{amt}</b> from user ID: <code>{uid}</code>"
        success_msg += format_message_footer()
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
    finally:
        await release_db(db)


async def admin_block(update, context):
    """Block a user"""
    if not is_admin(update.effective_user.id) or not context.args:
        return
    
    uid = int(context.args[0])
    
    db = await get_db()
    try:
        await db.execute("UPDATE users SET blocked = 1 WHERE user_id = ?", (uid,))
        await db.commit()
        
        success_msg = format_message_header("USER BLOCKED", "ğŸš«")
        success_msg += f"Target ID: <code>{uid}</code>"
        success_msg += format_message_footer()
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
        
        settings = await get_bot_settings()
        protect_content = settings.get('protect_content', False)
        
        block_msg = format_error_message("Your account has been blocked by Admin.")
        try:
            await context.bot.send_message(uid, block_msg, parse_mode="HTML", protect_content=protect_content)
        except:
            pass
    finally:
        await release_db(db)


async def admin_unblock(update, context):
    """Unblock a user"""
    if not is_admin(update.effective_user.id) or not context.args:
        return
    
    uid = int(context.args[0])
    
    db = await get_db()
    try:
        await db.execute("UPDATE users SET blocked = 0 WHERE user_id = ?", (uid,))
        await db.commit()
        
        success_msg = format_message_header("USER UNBLOCKED", "âœ…")
        success_msg += f"Target ID: <code>{uid}</code>"
        success_msg += format_message_footer()
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
        
        settings = await get_bot_settings()
        protect_content = settings.get('protect_content', False)
        
        unblock_msg = format_success_message("Welcome back! Restrictions lifted.")
        try:
            await context.bot.send_message(uid, unblock_msg, parse_mode="HTML", protect_content=protect_content)
        except:
            pass
    finally:
        await release_db(db)


async def admin_grantall(update, context):
    """Enable unlimited mode for all users"""
    if not is_admin(update.effective_user.id) or not context.args:
        return
    
    mins = int(context.args[0])
    end_t = now_ist() + timedelta(minutes=mins)
    
    await update_bot_setting('grant_all_until', end_t.isoformat())
    
    settings = await get_bot_settings()
    protect_content = settings.get('protect_content', False)
    
    txt = format_message_header("GLOBAL EVENT: UNLIMITED MODE", "ğŸ")
    txt += f"ğŸ”“ <b>Status:</b> Unlimited Downloads\n"
    txt += f"ğŸ•’ <b>Ends At:</b> {end_t.strftime('%I:%M:%S %p')} IST"
    txt += format_message_footer()
    
    # Check if should include silent users (default: no)
    include_silent = len(context.args) > 1 and context.args[1].lower() == 'silent'
    
    await broadcast_queue.put({
        'message': txt,
        'admin_id': update.effective_user.id,
        'include_silent': include_silent
    })
    
    queue_msg = format_message_header("BROADCAST QUEUED", "ğŸ“¢")
    queue_msg += "Unlimited mode announcement is being sent to all users.\n\n"
    queue_msg += "â³ This will not block other operations."
    queue_msg += format_message_footer()
    
    await update.message.reply_text(queue_msg, parse_mode="HTML")


async def admin_stopgrantall(update, context):
    """Stop unlimited mode"""
    if not is_admin(update.effective_user.id):
        return
    
    await update_bot_setting('grant_all_until', '')
    
    stop_msg = format_message_header("EVENT STOPPED", "ğŸ›‘")
    stop_msg += "Unlimited Mode has been disconnected."
    stop_msg += format_message_footer()
    
    await update.message.reply_text(stop_msg, parse_mode="HTML")


async def admin_reset(update, context):
    """Reset user's daily usage"""
    if not is_admin(update.effective_user.id) or not context.args:
        return
    
    uid = int(context.args[0])
    
    db = await get_db()
    try:
        await db.execute("UPDATE users SET usage_today = 0 WHERE user_id = ?", (uid,))
        await db.commit()
        
        success_msg = format_message_header("RESET SUCCESS", "ğŸ”„")
        success_msg += f"Target ID: <code>{uid}</code>"
        success_msg += format_message_footer()
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
        
        settings = await get_bot_settings()
        protect_content = settings.get('protect_content', False)
        
        reset_msg = format_message_header("LIMITS RESET", "ğŸ”„")
        reset_msg += "Your daily usage has been reset to 0 by Admin."
        reset_msg += format_message_footer()
        
        try:
            await context.bot.send_message(uid, reset_msg, parse_mode="HTML", protect_content=protect_content)
        except:
            pass
    finally:
        await release_db(db)


async def admin_addadmin(update, context):
    """Add sub-admin"""
    if not is_owner(update.effective_user.id) or not context.args:
        return
    
    uid = int(context.args[0])
    
    db = await get_db()
    try:
        await db.execute("UPDATE users SET is_sub_admin = 1 WHERE user_id = ?", (uid,))
        await db.commit()
        
        SUB_ADMINS.add(uid)
        
        success_msg = format_message_header("SUB-ADMIN ADDED", "ğŸ‘¤")
        success_msg += f"User ID: <code>{uid}</code>\n\n"
        success_msg += "They can now use all admin commands except:\n"
        success_msg += "  â€¢ Adding/removing sub-admins\n"
        success_msg += "  â€¢ Deleting databases"
        success_msg += format_message_footer()
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
        
        settings = await get_bot_settings()
        protect_content = settings.get('protect_content', False)
        
        admin_msg = format_message_header("PROMOTED TO SUB-ADMIN", "â­")
        admin_msg += "You have been granted admin privileges!\n\n"
        admin_msg += "Use /adminpanel to access the admin panel."
        admin_msg += format_message_footer()
        
        try:
            await context.bot.send_message(uid, admin_msg, parse_mode="HTML", protect_content=protect_content)
        except:
            pass
    finally:
        await release_db(db)


async def admin_removeadmin(update, context):
    """Remove sub-admin"""
    if not is_owner(update.effective_user.id) or not context.args:
        return
    
    uid = int(context.args[0])
    
    db = await get_db()
    try:
        await db.execute("UPDATE users SET is_sub_admin = 0 WHERE user_id = ?", (uid,))
        await db.commit()
        
        SUB_ADMINS.discard(uid)
        
        success_msg = format_message_header("SUB-ADMIN REMOVED", "âŒ")
        success_msg += f"User ID: <code>{uid}</code>"
        success_msg += format_message_footer()
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
        
        settings = await get_bot_settings()
        protect_content = settings.get('protect_content', False)
        
        admin_msg = format_message_header("ADMIN PRIVILEGES REVOKED", "âš ï¸")
        admin_msg += "Your admin privileges have been removed."
        admin_msg += format_message_footer()
        
        try:
            await context.bot.send_message(uid, admin_msg, parse_mode="HTML", protect_content=protect_content)
        except:
            pass
    finally:
        await release_db(db)


async def admin_delvideo(update, context):
    """Delete a video from database"""
    if not is_admin(update.effective_user.id) or not context.args:
        return
    
    video_id = int(context.args[0])
    
    db = await get_db()
    try:
        await db.execute("DELETE FROM videos WHERE msg_id = ?", (video_id,))
        await db.commit()
        
        success_msg = format_message_header("VIDEO DELETED", "ğŸ—‘ï¸")
        success_msg += f"Video ID: <code>{video_id}</code>"
        success_msg += format_message_footer()
        
        await update.message.reply_text(success_msg, parse_mode="HTML")
    finally:
        await release_db(db)


async def admin_broadcast(update, context):
    """Broadcast message - NON-BLOCKING"""
    if not is_admin(update.effective_user.id) or not update.message.reply_to_message:
        return
    
    # Check if should include silent users
    include_silent = context.args and context.args[0].lower() == 'silent'
    
    await broadcast_queue.put({
        'message': None,
        'message_id': update.message.reply_to_message.message_id,
        'from_chat_id': update.effective_chat.id,
        'admin_id': update.effective_user.id,
        'include_silent': include_silent
    })
    
    queue_msg = format_message_header("BROADCAST QUEUED", "ğŸ“¢")
    queue_msg += "âœ… Your message is being sent to all users in the background.\n\n"
    
    if include_silent:
        queue_msg += "ğŸ“¢ <b>Mode:</b> Normal users + Silent users\n"
    else:
        queue_msg += "ğŸ“¢ <b>Mode:</b> Normal users only\n"
    
    queue_msg += "\nâ³ You can continue using the bot normally.\n"
    queue_msg += "ğŸ’¡ You'll receive a report when complete."
    queue_msg += format_message_footer()
    
    await update.message.reply_text(queue_msg, parse_mode="HTML")


async def admin_backup(update, context):
    """Manual backup database"""
    if not is_admin(update.effective_user.id):
        return
    
    ts = now_ist().strftime('%d/%m/%Y %I:%M %p')
    
    if os.path.exists(DB_PATH):
        try:
            with open(DB_PATH, "rb") as f:
                caption = f"ğŸ’¾ <b>DATABASE BACKUP</b>\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ° {ts}\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
                await context.bot.send_document(
                    chat_id=LOG_CHANNEL_ID,
                    document=f,
                    caption=caption,
                    parse_mode="HTML"
                )
            
            success_msg = format_message_header("BACKUP DISPATCHED", "ğŸš€")
            success_msg += "Database backed up to Log Channel."
            success_msg += format_message_footer()
            
            await update.message.reply_text(success_msg, parse_mode="HTML")
        except Exception as e:
            logging.error(f"[BACKUP] Error: {e}")
            await update.message.reply_text(
                format_error_message(f"Backup failed: {str(e)}"),
                parse_mode="HTML"
            )


async def admin_deletedb(update, context):
    """Delete database tables - OWNER ONLY"""
    if not is_owner(update.effective_user.id) or not context.args:
        return
    
    db_type = context.args[0].lower()
    
    # Ask for confirmation
    kb = [
        [InlineKeyboardButton("âœ… YES, DELETE IT", callback_data=f"confirm_deletedb:{db_type}")],
        [InlineKeyboardButton("âŒ CANCEL", callback_data="admin_panel:database_mgmt")]
    ]
    
    confirm_text = format_message_header("âš ï¸ CONFIRM DELETION", "ğŸ—‘ï¸")
    confirm_text += f"\n<b>Target:</b> {db_type.upper()}\n\n"
    confirm_text += "âš ï¸ <b>WARNING:</b> This action cannot be undone!\n\n"
    confirm_text += "Are you absolutely sure?"
    confirm_text += format_message_footer()
    
    await update.message.reply_text(
        confirm_text,
        reply_markup=InlineKeyboardMarkup(kb),
        parse_mode="HTML"
    )


async def handle_recovery(update, context):
    """Handle database recovery - Admin only"""
    # Check if user is admin FIRST
    if not is_admin(update.effective_user.id):
        return  # Silently ignore non-admin uploads
    
    # Check if document exists
    if not update.message.document:
        return
    
    doc = update.message.document
    
    if doc.file_name.endswith('.db'):
        try:
            # Download the file
            f = await context.bot.get_file(doc.file_id)
            await f.download_to_drive(DB_PATH)
            
            success_msg = format_success_message(
                f"Database <code>{doc.file_name}</code> has been restored.\n\n"
                f"ğŸ”„ Reinitializing database..."
            )
            
            await update.message.reply_text(success_msg, parse_mode="HTML")
            
            # Reinitialize database
            await init_database()
            await init_enhanced_features_tables()
            
            completion_msg = format_success_message(
                "âœ… Database recovery complete!\n\n"
                "Bot is ready to use."
            )
            await update.message.reply_text(completion_msg, parse_mode="HTML")
            
        except Exception as e:
            logging.error(f"[RECOVERY] Error: {e}")
            await update.message.reply_text(
                format_error_message(f"Recovery failed: {str(e)}"),
                parse_mode="HTML"
            )
    else:
        error_msg = format_error_message(
            "Invalid file type!\n\n"
            "Please send a valid database file (.db)"
        )
        
        await update.message.reply_text(error_msg, parse_mode="HTML")        
